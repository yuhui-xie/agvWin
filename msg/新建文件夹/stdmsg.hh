// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stdmsg.proto

#ifndef PROTOBUF_stdmsg_2eproto__INCLUDED
#define PROTOBUF_stdmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace stdmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_stdmsg_2eproto();
void protobuf_AssignDesc_stdmsg_2eproto();
void protobuf_ShutdownFile_stdmsg_2eproto();

class Position;
class Orentation;
class Pose;
class Velocity;
class Laser_Scan;
class Laser_Scan_Laser_Config;
class Global_Plan;
class Data;
class String;
class LaserList;

// ===================================================================

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orentation : public ::google::protobuf::Message {
 public:
  Orentation();
  virtual ~Orentation();

  Orentation(const Orentation& from);

  inline Orentation& operator=(const Orentation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orentation& default_instance();

  void Swap(Orentation* other);

  // implements Message ----------------------------------------------

  Orentation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orentation& from);
  void MergeFrom(const Orentation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double roll = 1 [default = 0];
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 1;
  inline double roll() const;
  inline void set_roll(double value);

  // optional double pitch = 2 [default = 0];
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 2;
  inline double pitch() const;
  inline void set_pitch(double value);

  // required double yaw = 3 [default = 0];
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 3;
  inline double yaw() const;
  inline void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Orentation)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double roll_;
  double pitch_;
  double yaw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Orentation* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  Pose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .stdmsg.Position position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::stdmsg::Position& position() const;
  inline ::stdmsg::Position* mutable_position();
  inline ::stdmsg::Position* release_position();
  inline void set_allocated_position(::stdmsg::Position* position);

  // required .stdmsg.Orentation orentation = 2;
  inline bool has_orentation() const;
  inline void clear_orentation();
  static const int kOrentationFieldNumber = 2;
  inline const ::stdmsg::Orentation& orentation() const;
  inline ::stdmsg::Orentation* mutable_orentation();
  inline ::stdmsg::Orentation* release_orentation();
  inline void set_allocated_orentation(::stdmsg::Orentation* orentation);

  // @@protoc_insertion_point(class_scope:stdmsg.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orentation();
  inline void clear_has_orentation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::stdmsg::Position* position_;
  ::stdmsg::Orentation* orentation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class Velocity : public ::google::protobuf::Message {
 public:
  Velocity();
  virtual ~Velocity();

  Velocity(const Velocity& from);

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity& default_instance();

  void Swap(Velocity* other);

  // implements Message ----------------------------------------------

  Velocity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double v = 1 [default = 0];
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 1;
  inline double v() const;
  inline void set_v(double value);

  // required double w = 2 [default = 0];
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 2;
  inline double w() const;
  inline void set_w(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Velocity)
 private:
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double v_;
  double w_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Velocity* default_instance_;
};
// -------------------------------------------------------------------

class Laser_Scan_Laser_Config : public ::google::protobuf::Message {
 public:
  Laser_Scan_Laser_Config();
  virtual ~Laser_Scan_Laser_Config();

  Laser_Scan_Laser_Config(const Laser_Scan_Laser_Config& from);

  inline Laser_Scan_Laser_Config& operator=(const Laser_Scan_Laser_Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Laser_Scan_Laser_Config& default_instance();

  void Swap(Laser_Scan_Laser_Config* other);

  // implements Message ----------------------------------------------

  Laser_Scan_Laser_Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Laser_Scan_Laser_Config& from);
  void MergeFrom(const Laser_Scan_Laser_Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float angle_min = 1;
  inline bool has_angle_min() const;
  inline void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  inline float angle_min() const;
  inline void set_angle_min(float value);

  // required float angle_max = 2;
  inline bool has_angle_max() const;
  inline void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  inline float angle_max() const;
  inline void set_angle_max(float value);

  // required float angle_increment = 3;
  inline bool has_angle_increment() const;
  inline void clear_angle_increment();
  static const int kAngleIncrementFieldNumber = 3;
  inline float angle_increment() const;
  inline void set_angle_increment(float value);

  // required float range_max = 5;
  inline bool has_range_max() const;
  inline void clear_range_max();
  static const int kRangeMaxFieldNumber = 5;
  inline float range_max() const;
  inline void set_range_max(float value);

  // @@protoc_insertion_point(class_scope:stdmsg.Laser_Scan.Laser_Config)
 private:
  inline void set_has_angle_min();
  inline void clear_has_angle_min();
  inline void set_has_angle_max();
  inline void clear_has_angle_max();
  inline void set_has_angle_increment();
  inline void clear_has_angle_increment();
  inline void set_has_range_max();
  inline void clear_has_range_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float angle_min_;
  float angle_max_;
  float angle_increment_;
  float range_max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Laser_Scan_Laser_Config* default_instance_;
};
// -------------------------------------------------------------------

class Laser_Scan : public ::google::protobuf::Message {
 public:
  Laser_Scan();
  virtual ~Laser_Scan();

  Laser_Scan(const Laser_Scan& from);

  inline Laser_Scan& operator=(const Laser_Scan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Laser_Scan& default_instance();

  void Swap(Laser_Scan* other);

  // implements Message ----------------------------------------------

  Laser_Scan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Laser_Scan& from);
  void MergeFrom(const Laser_Scan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Laser_Scan_Laser_Config Laser_Config;

  // accessors -------------------------------------------------------

  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 1;
  inline const ::stdmsg::Laser_Scan_Laser_Config& config() const;
  inline ::stdmsg::Laser_Scan_Laser_Config* mutable_config();
  inline ::stdmsg::Laser_Scan_Laser_Config* release_config();
  inline void set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config);

  // repeated float ranges = 2;
  inline int ranges_size() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 2;
  inline float ranges(int index) const;
  inline void set_ranges(int index, float value);
  inline void add_ranges(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      ranges() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_ranges();

  // repeated float intensities = 3;
  inline int intensities_size() const;
  inline void clear_intensities();
  static const int kIntensitiesFieldNumber = 3;
  inline float intensities(int index) const;
  inline void set_intensities(int index, float value);
  inline void add_intensities(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      intensities() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_intensities();

  // required .stdmsg.Pose pose = 5;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 5;
  inline const ::stdmsg::Pose& pose() const;
  inline ::stdmsg::Pose* mutable_pose();
  inline ::stdmsg::Pose* release_pose();
  inline void set_allocated_pose(::stdmsg::Pose* pose);

  // required .stdmsg.Pose robot = 6;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 6;
  inline const ::stdmsg::Pose& robot() const;
  inline ::stdmsg::Pose* mutable_robot();
  inline ::stdmsg::Pose* release_robot();
  inline void set_allocated_robot(::stdmsg::Pose* robot);

  // optional double steer = 9;
  inline bool has_steer() const;
  inline void clear_steer();
  static const int kSteerFieldNumber = 9;
  inline double steer() const;
  inline void set_steer(double value);

  // optional int32 seq = 7 [default = 0];
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 7;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // optional string annotation = 8 [default = ""];
  inline bool has_annotation() const;
  inline void clear_annotation();
  static const int kAnnotationFieldNumber = 8;
  inline const ::std::string& annotation() const;
  inline void set_annotation(const ::std::string& value);
  inline void set_annotation(const char* value);
  inline void set_annotation(const char* value, size_t size);
  inline ::std::string* mutable_annotation();
  inline ::std::string* release_annotation();
  inline void set_allocated_annotation(::std::string* annotation);

  // @@protoc_insertion_point(class_scope:stdmsg.Laser_Scan)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_steer();
  inline void clear_has_steer();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_annotation();
  inline void clear_has_annotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::stdmsg::Laser_Scan_Laser_Config* config_;
  ::google::protobuf::RepeatedField< float > ranges_;
  ::google::protobuf::RepeatedField< float > intensities_;
  ::stdmsg::Pose* pose_;
  ::stdmsg::Pose* robot_;
  double steer_;
  ::std::string* annotation_;
  ::google::protobuf::int32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Laser_Scan* default_instance_;
};
// -------------------------------------------------------------------

class Global_Plan : public ::google::protobuf::Message {
 public:
  Global_Plan();
  virtual ~Global_Plan();

  Global_Plan(const Global_Plan& from);

  inline Global_Plan& operator=(const Global_Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Global_Plan& default_instance();

  void Swap(Global_Plan* other);

  // implements Message ----------------------------------------------

  Global_Plan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Global_Plan& from);
  void MergeFrom(const Global_Plan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Pose path = 1;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::stdmsg::Pose& path(int index) const;
  inline ::stdmsg::Pose* mutable_path(int index);
  inline ::stdmsg::Pose* add_path();
  inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
      path() const;
  inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
      mutable_path();

  // optional int32 seq = 2 [default = 0];
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // optional int32 goal_reached = 3 [default = 0];
  inline bool has_goal_reached() const;
  inline void clear_goal_reached();
  static const int kGoalReachedFieldNumber = 3;
  inline ::google::protobuf::int32 goal_reached() const;
  inline void set_goal_reached(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Global_Plan)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_goal_reached();
  inline void clear_has_goal_reached();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose > path_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 goal_reached_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Global_Plan* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1 [default = ""];
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int32 seq = 2 [default = 0];
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Data)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  ::google::protobuf::int32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class String : public ::google::protobuf::Message {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const String& default_instance();

  void Swap(String* other);

  // implements Message ----------------------------------------------

  String* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string str = 1 [default = ""];
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // optional int32 seq = 2 [default = 0];
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.String)
 private:
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;
  ::google::protobuf::int32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static String* default_instance_;
};
// -------------------------------------------------------------------

class LaserList : public ::google::protobuf::Message {
 public:
  LaserList();
  virtual ~LaserList();

  LaserList(const LaserList& from);

  inline LaserList& operator=(const LaserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserList& default_instance();

  void Swap(LaserList* other);

  // implements Message ----------------------------------------------

  LaserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserList& from);
  void MergeFrom(const LaserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Laser_Scan scans = 1;
  inline int scans_size() const;
  inline void clear_scans();
  static const int kScansFieldNumber = 1;
  inline const ::stdmsg::Laser_Scan& scans(int index) const;
  inline ::stdmsg::Laser_Scan* mutable_scans(int index);
  inline ::stdmsg::Laser_Scan* add_scans();
  inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
      scans() const;
  inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
      mutable_scans();

  // optional int32 seq = 2 [default = 0];
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.LaserList)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan > scans_;
  ::google::protobuf::int32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static LaserList* default_instance_;
};
// ===================================================================


// ===================================================================

// Position

// required double x = 1 [default = 0];
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Position::x() const {
  return x_;
}
inline void Position::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2 [default = 0];
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Position::y() const {
  return y_;
}
inline void Position::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double z = 3 [default = 0];
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Position::z() const {
  return z_;
}
inline void Position::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Orentation

// optional double roll = 1 [default = 0];
inline bool Orentation::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orentation::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orentation::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orentation::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double Orentation::roll() const {
  return roll_;
}
inline void Orentation::set_roll(double value) {
  set_has_roll();
  roll_ = value;
}

// optional double pitch = 2 [default = 0];
inline bool Orentation::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orentation::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orentation::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orentation::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double Orentation::pitch() const {
  return pitch_;
}
inline void Orentation::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
}

// required double yaw = 3 [default = 0];
inline bool Orentation::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orentation::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orentation::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orentation::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double Orentation::yaw() const {
  return yaw_;
}
inline void Orentation::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
}

// -------------------------------------------------------------------

// Pose

// required .stdmsg.Position position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::stdmsg::Position::Clear();
  clear_has_position();
}
inline const ::stdmsg::Position& Pose::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::stdmsg::Position* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::stdmsg::Position;
  return position_;
}
inline ::stdmsg::Position* Pose::release_position() {
  clear_has_position();
  ::stdmsg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::stdmsg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required .stdmsg.Orentation orentation = 2;
inline bool Pose::has_orentation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orentation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orentation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orentation() {
  if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
  clear_has_orentation();
}
inline const ::stdmsg::Orentation& Pose::orentation() const {
  return orentation_ != NULL ? *orentation_ : *default_instance_->orentation_;
}
inline ::stdmsg::Orentation* Pose::mutable_orentation() {
  set_has_orentation();
  if (orentation_ == NULL) orentation_ = new ::stdmsg::Orentation;
  return orentation_;
}
inline ::stdmsg::Orentation* Pose::release_orentation() {
  clear_has_orentation();
  ::stdmsg::Orentation* temp = orentation_;
  orentation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orentation(::stdmsg::Orentation* orentation) {
  delete orentation_;
  orentation_ = orentation;
  if (orentation) {
    set_has_orentation();
  } else {
    clear_has_orentation();
  }
}

// -------------------------------------------------------------------

// Velocity

// required double v = 1 [default = 0];
inline bool Velocity::has_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Velocity::set_has_v() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Velocity::clear_has_v() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Velocity::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double Velocity::v() const {
  return v_;
}
inline void Velocity::set_v(double value) {
  set_has_v();
  v_ = value;
}

// required double w = 2 [default = 0];
inline bool Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Velocity::w() const {
  return w_;
}
inline void Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
}

// -------------------------------------------------------------------

// Laser_Scan_Laser_Config

// required float angle_min = 1;
inline bool Laser_Scan_Laser_Config::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Laser_Scan_Laser_Config::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
inline float Laser_Scan_Laser_Config::angle_min() const {
  return angle_min_;
}
inline void Laser_Scan_Laser_Config::set_angle_min(float value) {
  set_has_angle_min();
  angle_min_ = value;
}

// required float angle_max = 2;
inline bool Laser_Scan_Laser_Config::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Laser_Scan_Laser_Config::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
inline float Laser_Scan_Laser_Config::angle_max() const {
  return angle_max_;
}
inline void Laser_Scan_Laser_Config::set_angle_max(float value) {
  set_has_angle_max();
  angle_max_ = value;
}

// required float angle_increment = 3;
inline bool Laser_Scan_Laser_Config::has_angle_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_increment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Laser_Scan_Laser_Config::clear_angle_increment() {
  angle_increment_ = 0;
  clear_has_angle_increment();
}
inline float Laser_Scan_Laser_Config::angle_increment() const {
  return angle_increment_;
}
inline void Laser_Scan_Laser_Config::set_angle_increment(float value) {
  set_has_angle_increment();
  angle_increment_ = value;
}

// required float range_max = 5;
inline bool Laser_Scan_Laser_Config::has_range_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_range_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Laser_Scan_Laser_Config::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Laser_Scan_Laser_Config::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
inline float Laser_Scan_Laser_Config::range_max() const {
  return range_max_;
}
inline void Laser_Scan_Laser_Config::set_range_max(float value) {
  set_has_range_max();
  range_max_ = value;
}

// -------------------------------------------------------------------

// Laser_Scan

// required .stdmsg.Laser_Scan.Laser_Config config = 1;
inline bool Laser_Scan::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Laser_Scan::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Laser_Scan::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Laser_Scan::clear_config() {
  if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
  clear_has_config();
}
inline const ::stdmsg::Laser_Scan_Laser_Config& Laser_Scan::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::stdmsg::Laser_Scan_Laser_Config;
  return config_;
}
inline ::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::release_config() {
  clear_has_config();
  ::stdmsg::Laser_Scan_Laser_Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// repeated float ranges = 2;
inline int Laser_Scan::ranges_size() const {
  return ranges_.size();
}
inline void Laser_Scan::clear_ranges() {
  ranges_.Clear();
}
inline float Laser_Scan::ranges(int index) const {
  return ranges_.Get(index);
}
inline void Laser_Scan::set_ranges(int index, float value) {
  ranges_.Set(index, value);
}
inline void Laser_Scan::add_ranges(float value) {
  ranges_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges() const {
  return ranges_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges() {
  return &ranges_;
}

// repeated float intensities = 3;
inline int Laser_Scan::intensities_size() const {
  return intensities_.size();
}
inline void Laser_Scan::clear_intensities() {
  intensities_.Clear();
}
inline float Laser_Scan::intensities(int index) const {
  return intensities_.Get(index);
}
inline void Laser_Scan::set_intensities(int index, float value) {
  intensities_.Set(index, value);
}
inline void Laser_Scan::add_intensities(float value) {
  intensities_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::intensities() const {
  return intensities_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_intensities() {
  return &intensities_;
}

// required .stdmsg.Pose pose = 5;
inline bool Laser_Scan::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Laser_Scan::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Laser_Scan::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Laser_Scan::clear_pose() {
  if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
  clear_has_pose();
}
inline const ::stdmsg::Pose& Laser_Scan::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::stdmsg::Pose* Laser_Scan::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::stdmsg::Pose;
  return pose_;
}
inline ::stdmsg::Pose* Laser_Scan::release_pose() {
  clear_has_pose();
  ::stdmsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_pose(::stdmsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
}

// required .stdmsg.Pose robot = 6;
inline bool Laser_Scan::has_robot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Laser_Scan::set_has_robot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Laser_Scan::clear_has_robot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Laser_Scan::clear_robot() {
  if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
  clear_has_robot();
}
inline const ::stdmsg::Pose& Laser_Scan::robot() const {
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::stdmsg::Pose* Laser_Scan::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) robot_ = new ::stdmsg::Pose;
  return robot_;
}
inline ::stdmsg::Pose* Laser_Scan::release_robot() {
  clear_has_robot();
  ::stdmsg::Pose* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_robot(::stdmsg::Pose* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
}

// optional double steer = 9;
inline bool Laser_Scan::has_steer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Laser_Scan::set_has_steer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Laser_Scan::clear_has_steer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Laser_Scan::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
inline double Laser_Scan::steer() const {
  return steer_;
}
inline void Laser_Scan::set_steer(double value) {
  set_has_steer();
  steer_ = value;
}

// optional int32 seq = 7 [default = 0];
inline bool Laser_Scan::has_seq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Laser_Scan::set_has_seq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Laser_Scan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Laser_Scan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Laser_Scan::seq() const {
  return seq_;
}
inline void Laser_Scan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// optional string annotation = 8 [default = ""];
inline bool Laser_Scan::has_annotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Laser_Scan::set_has_annotation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Laser_Scan::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Laser_Scan::clear_annotation() {
  if (annotation_ != &::google::protobuf::internal::kEmptyString) {
    annotation_->clear();
  }
  clear_has_annotation();
}
inline const ::std::string& Laser_Scan::annotation() const {
  return *annotation_;
}
inline void Laser_Scan::set_annotation(const ::std::string& value) {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::kEmptyString) {
    annotation_ = new ::std::string;
  }
  annotation_->assign(value);
}
inline void Laser_Scan::set_annotation(const char* value) {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::kEmptyString) {
    annotation_ = new ::std::string;
  }
  annotation_->assign(value);
}
inline void Laser_Scan::set_annotation(const char* value, size_t size) {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::kEmptyString) {
    annotation_ = new ::std::string;
  }
  annotation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Laser_Scan::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::kEmptyString) {
    annotation_ = new ::std::string;
  }
  return annotation_;
}
inline ::std::string* Laser_Scan::release_annotation() {
  clear_has_annotation();
  if (annotation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = annotation_;
    annotation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Laser_Scan::set_allocated_annotation(::std::string* annotation) {
  if (annotation_ != &::google::protobuf::internal::kEmptyString) {
    delete annotation_;
  }
  if (annotation) {
    set_has_annotation();
    annotation_ = annotation;
  } else {
    clear_has_annotation();
    annotation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Global_Plan

// repeated .stdmsg.Pose path = 1;
inline int Global_Plan::path_size() const {
  return path_.size();
}
inline void Global_Plan::clear_path() {
  path_.Clear();
}
inline const ::stdmsg::Pose& Global_Plan::path(int index) const {
  return path_.Get(index);
}
inline ::stdmsg::Pose* Global_Plan::mutable_path(int index) {
  return path_.Mutable(index);
}
inline ::stdmsg::Pose* Global_Plan::add_path() {
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
Global_Plan::path() const {
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
Global_Plan::mutable_path() {
  return &path_;
}

// optional int32 seq = 2 [default = 0];
inline bool Global_Plan::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Global_Plan::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Global_Plan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Global_Plan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Global_Plan::seq() const {
  return seq_;
}
inline void Global_Plan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// optional int32 goal_reached = 3 [default = 0];
inline bool Global_Plan::has_goal_reached() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Global_Plan::set_has_goal_reached() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Global_Plan::clear_has_goal_reached() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Global_Plan::clear_goal_reached() {
  goal_reached_ = 0;
  clear_has_goal_reached();
}
inline ::google::protobuf::int32 Global_Plan::goal_reached() const {
  return goal_reached_;
}
inline void Global_Plan::set_goal_reached(::google::protobuf::int32 value) {
  set_has_goal_reached();
  goal_reached_ = value;
}

// -------------------------------------------------------------------

// Data

// optional bytes data = 1 [default = ""];
inline bool Data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Data::data() const {
  return *data_;
}
inline void Data::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Data::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Data::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Data::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Data::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Data::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 seq = 2 [default = 0];
inline bool Data::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Data::seq() const {
  return seq_;
}
inline void Data::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// String

// optional string str = 1 [default = ""];
inline bool String::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void String::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void String::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void String::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& String::str() const {
  return *str_;
}
inline void String::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void String::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void String::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* String::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* String::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void String::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 seq = 2 [default = 0];
inline bool String::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void String::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void String::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void String::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 String::seq() const {
  return seq_;
}
inline void String::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// LaserList

// repeated .stdmsg.Laser_Scan scans = 1;
inline int LaserList::scans_size() const {
  return scans_.size();
}
inline void LaserList::clear_scans() {
  scans_.Clear();
}
inline const ::stdmsg::Laser_Scan& LaserList::scans(int index) const {
  return scans_.Get(index);
}
inline ::stdmsg::Laser_Scan* LaserList::mutable_scans(int index) {
  return scans_.Mutable(index);
}
inline ::stdmsg::Laser_Scan* LaserList::add_scans() {
  return scans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
LaserList::scans() const {
  return scans_;
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
LaserList::mutable_scans() {
  return &scans_;
}

// optional int32 seq = 2 [default = 0];
inline bool LaserList::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaserList::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaserList::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaserList::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 LaserList::seq() const {
  return seq_;
}
inline void LaserList::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace stdmsg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_stdmsg_2eproto__INCLUDED
