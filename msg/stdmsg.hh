// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stdmsg.proto

#ifndef PROTOBUF_stdmsg_2eproto__INCLUDED
#define PROTOBUF_stdmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace stdmsg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_stdmsg_2eproto();
void protobuf_AssignDesc_stdmsg_2eproto();
void protobuf_ShutdownFile_stdmsg_2eproto();

class Data;
class Global_Plan;
class LaserList;
class Laser_Scan;
class Laser_Scan_Laser_Config;
class Light;
class MoveMode;
class NavConfig;
class Orentation;
class Pose;
class Pose_Velocity;
class Position;
class SomeFlag;
class String;
class Velocity;

// ===================================================================

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orentation : public ::google::protobuf::Message {
 public:
  Orentation();
  virtual ~Orentation();

  Orentation(const Orentation& from);

  inline Orentation& operator=(const Orentation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orentation& default_instance();

  void Swap(Orentation* other);

  // implements Message ----------------------------------------------

  inline Orentation* New() const { return New(NULL); }

  Orentation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orentation& from);
  void MergeFrom(const Orentation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orentation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double roll = 1 [default = 0];
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  double roll() const;
  void set_roll(double value);

  // optional double pitch = 2 [default = 0];
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  double pitch() const;
  void set_pitch(double value);

  // required double yaw = 3 [default = 0];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  double yaw() const;
  void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Orentation)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double roll_;
  double pitch_;
  double yaw_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Orentation* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  inline Pose* New() const { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .stdmsg.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::stdmsg::Position& position() const;
  ::stdmsg::Position* mutable_position();
  ::stdmsg::Position* release_position();
  void set_allocated_position(::stdmsg::Position* position);

  // required .stdmsg.Orentation orentation = 2;
  bool has_orentation() const;
  void clear_orentation();
  static const int kOrentationFieldNumber = 2;
  const ::stdmsg::Orentation& orentation() const;
  ::stdmsg::Orentation* mutable_orentation();
  ::stdmsg::Orentation* release_orentation();
  void set_allocated_orentation(::stdmsg::Orentation* orentation);

  // @@protoc_insertion_point(class_scope:stdmsg.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orentation();
  inline void clear_has_orentation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::stdmsg::Position* position_;
  ::stdmsg::Orentation* orentation_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class Velocity : public ::google::protobuf::Message {
 public:
  Velocity();
  virtual ~Velocity();

  Velocity(const Velocity& from);

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity& default_instance();

  void Swap(Velocity* other);

  // implements Message ----------------------------------------------

  inline Velocity* New() const { return New(NULL); }

  Velocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Velocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double v = 1 [default = 0];
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 1;
  double v() const;
  void set_v(double value);

  // required double w = 2 [default = 0];
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 2;
  double w() const;
  void set_w(double value);

  // optional double v2 = 3 [default = 0];
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 3;
  double v2() const;
  void set_v2(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Velocity)
 private:
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_v2();
  inline void clear_has_v2();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double v_;
  double w_;
  double v2_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Velocity* default_instance_;
};
// -------------------------------------------------------------------

class Pose_Velocity : public ::google::protobuf::Message {
 public:
  Pose_Velocity();
  virtual ~Pose_Velocity();

  Pose_Velocity(const Pose_Velocity& from);

  inline Pose_Velocity& operator=(const Pose_Velocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose_Velocity& default_instance();

  void Swap(Pose_Velocity* other);

  // implements Message ----------------------------------------------

  inline Pose_Velocity* New() const { return New(NULL); }

  Pose_Velocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose_Velocity& from);
  void MergeFrom(const Pose_Velocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pose_Velocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double yaw = 3 [default = 0];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  double yaw() const;
  void set_yaw(double value);

  // required double vx = 4 [default = 0];
  bool has_vx() const;
  void clear_vx();
  static const int kVxFieldNumber = 4;
  double vx() const;
  void set_vx(double value);

  // required double vy = 5 [default = 0];
  bool has_vy() const;
  void clear_vy();
  static const int kVyFieldNumber = 5;
  double vy() const;
  void set_vy(double value);

  // required double w = 6 [default = 0];
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 6;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Pose_Velocity)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_vx();
  inline void clear_has_vx();
  inline void set_has_vy();
  inline void clear_has_vy();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double yaw_;
  double vx_;
  double vy_;
  double w_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Pose_Velocity* default_instance_;
};
// -------------------------------------------------------------------

class Laser_Scan_Laser_Config : public ::google::protobuf::Message {
 public:
  Laser_Scan_Laser_Config();
  virtual ~Laser_Scan_Laser_Config();

  Laser_Scan_Laser_Config(const Laser_Scan_Laser_Config& from);

  inline Laser_Scan_Laser_Config& operator=(const Laser_Scan_Laser_Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Laser_Scan_Laser_Config& default_instance();

  void Swap(Laser_Scan_Laser_Config* other);

  // implements Message ----------------------------------------------

  inline Laser_Scan_Laser_Config* New() const { return New(NULL); }

  Laser_Scan_Laser_Config* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Laser_Scan_Laser_Config& from);
  void MergeFrom(const Laser_Scan_Laser_Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Laser_Scan_Laser_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float angle_min = 1;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  float angle_min() const;
  void set_angle_min(float value);

  // required float angle_max = 2;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  float angle_max() const;
  void set_angle_max(float value);

  // required float angle_increment = 3;
  bool has_angle_increment() const;
  void clear_angle_increment();
  static const int kAngleIncrementFieldNumber = 3;
  float angle_increment() const;
  void set_angle_increment(float value);

  // required float range_max = 5;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 5;
  float range_max() const;
  void set_range_max(float value);

  // @@protoc_insertion_point(class_scope:stdmsg.Laser_Scan.Laser_Config)
 private:
  inline void set_has_angle_min();
  inline void clear_has_angle_min();
  inline void set_has_angle_max();
  inline void clear_has_angle_max();
  inline void set_has_angle_increment();
  inline void clear_has_angle_increment();
  inline void set_has_range_max();
  inline void clear_has_range_max();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float angle_min_;
  float angle_max_;
  float angle_increment_;
  float range_max_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Laser_Scan_Laser_Config* default_instance_;
};
// -------------------------------------------------------------------

class Laser_Scan : public ::google::protobuf::Message {
 public:
  Laser_Scan();
  virtual ~Laser_Scan();

  Laser_Scan(const Laser_Scan& from);

  inline Laser_Scan& operator=(const Laser_Scan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Laser_Scan& default_instance();

  void Swap(Laser_Scan* other);

  // implements Message ----------------------------------------------

  inline Laser_Scan* New() const { return New(NULL); }

  Laser_Scan* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Laser_Scan& from);
  void MergeFrom(const Laser_Scan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Laser_Scan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Laser_Scan_Laser_Config Laser_Config;

  // accessors -------------------------------------------------------

  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::stdmsg::Laser_Scan_Laser_Config& config() const;
  ::stdmsg::Laser_Scan_Laser_Config* mutable_config();
  ::stdmsg::Laser_Scan_Laser_Config* release_config();
  void set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config);

  // repeated float ranges = 2;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 2;
  float ranges(int index) const;
  void set_ranges(int index, float value);
  void add_ranges(float value);
  const ::google::protobuf::RepeatedField< float >&
      ranges() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_ranges();

  // repeated float intensities = 3;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 3;
  float intensities(int index) const;
  void set_intensities(int index, float value);
  void add_intensities(float value);
  const ::google::protobuf::RepeatedField< float >&
      intensities() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_intensities();

  // required .stdmsg.Pose pose = 5;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 5;
  const ::stdmsg::Pose& pose() const;
  ::stdmsg::Pose* mutable_pose();
  ::stdmsg::Pose* release_pose();
  void set_allocated_pose(::stdmsg::Pose* pose);

  // required .stdmsg.Pose robot = 6;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 6;
  const ::stdmsg::Pose& robot() const;
  ::stdmsg::Pose* mutable_robot();
  ::stdmsg::Pose* release_robot();
  void set_allocated_robot(::stdmsg::Pose* robot);

  // optional double steer = 9;
  bool has_steer() const;
  void clear_steer();
  static const int kSteerFieldNumber = 9;
  double steer() const;
  void set_steer(double value);

  // optional int32 seq = 7 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 7;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // optional string annotation = 8 [default = ""];
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 8;
  const ::std::string& annotation() const;
  void set_annotation(const ::std::string& value);
  void set_annotation(const char* value);
  void set_annotation(const char* value, size_t size);
  ::std::string* mutable_annotation();
  ::std::string* release_annotation();
  void set_allocated_annotation(::std::string* annotation);

  // @@protoc_insertion_point(class_scope:stdmsg.Laser_Scan)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_steer();
  inline void clear_has_steer();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_annotation();
  inline void clear_has_annotation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::stdmsg::Laser_Scan_Laser_Config* config_;
  ::google::protobuf::RepeatedField< float > ranges_;
  ::google::protobuf::RepeatedField< float > intensities_;
  ::stdmsg::Pose* pose_;
  ::stdmsg::Pose* robot_;
  double steer_;
  ::google::protobuf::internal::ArenaStringPtr annotation_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Laser_Scan* default_instance_;
};
// -------------------------------------------------------------------

class Global_Plan : public ::google::protobuf::Message {
 public:
  Global_Plan();
  virtual ~Global_Plan();

  Global_Plan(const Global_Plan& from);

  inline Global_Plan& operator=(const Global_Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Global_Plan& default_instance();

  void Swap(Global_Plan* other);

  // implements Message ----------------------------------------------

  inline Global_Plan* New() const { return New(NULL); }

  Global_Plan* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Global_Plan& from);
  void MergeFrom(const Global_Plan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Global_Plan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Pose path = 1;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::stdmsg::Pose& path(int index) const;
  ::stdmsg::Pose* mutable_path(int index);
  ::stdmsg::Pose* add_path();
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
      mutable_path();
  const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
      path() const;

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // optional int32 goal_reached = 3 [default = 0];
  bool has_goal_reached() const;
  void clear_goal_reached();
  static const int kGoalReachedFieldNumber = 3;
  ::google::protobuf::int32 goal_reached() const;
  void set_goal_reached(::google::protobuf::int32 value);

  // optional int32 distance_goal_reached = 4 [default = 0];
  bool has_distance_goal_reached() const;
  void clear_distance_goal_reached();
  static const int kDistanceGoalReachedFieldNumber = 4;
  ::google::protobuf::int32 distance_goal_reached() const;
  void set_distance_goal_reached(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Global_Plan)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_goal_reached();
  inline void clear_has_goal_reached();
  inline void set_has_distance_goal_reached();
  inline void clear_has_distance_goal_reached();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose > path_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 goal_reached_;
  ::google::protobuf::int32 distance_goal_reached_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Global_Plan* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  inline Data* New() const { return New(NULL); }

  Data* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1 [default = ""];
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Data)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class String : public ::google::protobuf::Message {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const String& default_instance();

  void Swap(String* other);

  // implements Message ----------------------------------------------

  inline String* New() const { return New(NULL); }

  String* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string str = 1 [default = ""];
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 1;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.String)
 private:
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static String* default_instance_;
};
// -------------------------------------------------------------------

class LaserList : public ::google::protobuf::Message {
 public:
  LaserList();
  virtual ~LaserList();

  LaserList(const LaserList& from);

  inline LaserList& operator=(const LaserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserList& default_instance();

  void Swap(LaserList* other);

  // implements Message ----------------------------------------------

  inline LaserList* New() const { return New(NULL); }

  LaserList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserList& from);
  void MergeFrom(const LaserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Laser_Scan scans = 1;
  int scans_size() const;
  void clear_scans();
  static const int kScansFieldNumber = 1;
  const ::stdmsg::Laser_Scan& scans(int index) const;
  ::stdmsg::Laser_Scan* mutable_scans(int index);
  ::stdmsg::Laser_Scan* add_scans();
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
      mutable_scans();
  const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
      scans() const;

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.LaserList)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan > scans_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static LaserList* default_instance_;
};
// -------------------------------------------------------------------

class MoveMode : public ::google::protobuf::Message {
 public:
  MoveMode();
  virtual ~MoveMode();

  MoveMode(const MoveMode& from);

  inline MoveMode& operator=(const MoveMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveMode& default_instance();

  void Swap(MoveMode* other);

  // implements Message ----------------------------------------------

  inline MoveMode* New() const { return New(NULL); }

  MoveMode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveMode& from);
  void MergeFrom(const MoveMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MoveMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 move_mode = 1 [default = 0];
  bool has_move_mode() const;
  void clear_move_mode();
  static const int kMoveModeFieldNumber = 1;
  ::google::protobuf::int32 move_mode() const;
  void set_move_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.MoveMode)
 private:
  inline void set_has_move_mode();
  inline void clear_has_move_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 move_mode_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static MoveMode* default_instance_;
};
// -------------------------------------------------------------------

class SomeFlag : public ::google::protobuf::Message {
 public:
  SomeFlag();
  virtual ~SomeFlag();

  SomeFlag(const SomeFlag& from);

  inline SomeFlag& operator=(const SomeFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SomeFlag& default_instance();

  void Swap(SomeFlag* other);

  // implements Message ----------------------------------------------

  inline SomeFlag* New() const { return New(NULL); }

  SomeFlag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SomeFlag& from);
  void MergeFrom(const SomeFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SomeFlag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 emergency_stop_flag = 1;
  bool has_emergency_stop_flag() const;
  void clear_emergency_stop_flag();
  static const int kEmergencyStopFlagFieldNumber = 1;
  ::google::protobuf::int32 emergency_stop_flag() const;
  void set_emergency_stop_flag(::google::protobuf::int32 value);

  // optional int32 obstacle_forward_flag = 2;
  bool has_obstacle_forward_flag() const;
  void clear_obstacle_forward_flag();
  static const int kObstacleForwardFlagFieldNumber = 2;
  ::google::protobuf::int32 obstacle_forward_flag() const;
  void set_obstacle_forward_flag(::google::protobuf::int32 value);

  // optional int32 move_mode_flag = 3;
  bool has_move_mode_flag() const;
  void clear_move_mode_flag();
  static const int kMoveModeFlagFieldNumber = 3;
  ::google::protobuf::int32 move_mode_flag() const;
  void set_move_mode_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.SomeFlag)
 private:
  inline void set_has_emergency_stop_flag();
  inline void clear_has_emergency_stop_flag();
  inline void set_has_obstacle_forward_flag();
  inline void clear_has_obstacle_forward_flag();
  inline void set_has_move_mode_flag();
  inline void clear_has_move_mode_flag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 emergency_stop_flag_;
  ::google::protobuf::int32 obstacle_forward_flag_;
  ::google::protobuf::int32 move_mode_flag_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static SomeFlag* default_instance_;
};
// -------------------------------------------------------------------

class NavConfig : public ::google::protobuf::Message {
 public:
  NavConfig();
  virtual ~NavConfig();

  NavConfig(const NavConfig& from);

  inline NavConfig& operator=(const NavConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavConfig& default_instance();

  void Swap(NavConfig* other);

  // implements Message ----------------------------------------------

  inline NavConfig* New() const { return New(NULL); }

  NavConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NavConfig& from);
  void MergeFrom(const NavConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NavConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_delta_distance = 1;
  bool has_stop_delta_distance() const;
  void clear_stop_delta_distance();
  static const int kStopDeltaDistanceFieldNumber = 1;
  double stop_delta_distance() const;
  void set_stop_delta_distance(double value);

  // optional double stop_delta_theta = 2;
  bool has_stop_delta_theta() const;
  void clear_stop_delta_theta();
  static const int kStopDeltaThetaFieldNumber = 2;
  double stop_delta_theta() const;
  void set_stop_delta_theta(double value);

  // optional double nav_v = 3;
  bool has_nav_v() const;
  void clear_nav_v();
  static const int kNavVFieldNumber = 3;
  double nav_v() const;
  void set_nav_v(double value);

  // optional double nav_w = 4;
  bool has_nav_w() const;
  void clear_nav_w();
  static const int kNavWFieldNumber = 4;
  double nav_w() const;
  void set_nav_w(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.NavConfig)
 private:
  inline void set_has_stop_delta_distance();
  inline void clear_has_stop_delta_distance();
  inline void set_has_stop_delta_theta();
  inline void clear_has_stop_delta_theta();
  inline void set_has_nav_v();
  inline void clear_has_nav_v();
  inline void set_has_nav_w();
  inline void clear_has_nav_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_delta_distance_;
  double stop_delta_theta_;
  double nav_v_;
  double nav_w_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static NavConfig* default_instance_;
};
// -------------------------------------------------------------------

class Light : public ::google::protobuf::Message {
 public:
  Light();
  virtual ~Light();

  Light(const Light& from);

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light& default_instance();

  void Swap(Light* other);

  // implements Message ----------------------------------------------

  inline Light* New() const { return New(NULL); }

  Light* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 lightflag = 1;
  bool has_lightflag() const;
  void clear_lightflag();
  static const int kLightflagFieldNumber = 1;
  ::google::protobuf::int32 lightflag() const;
  void set_lightflag(::google::protobuf::int32 value);

  // optional int32 number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Light)
 private:
  inline void set_has_lightflag();
  inline void clear_has_lightflag();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 lightflag_;
  ::google::protobuf::int32 number_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Light* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// required double x = 1 [default = 0];
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Position::x() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.x)
  return x_;
}
inline void Position::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.x)
}

// required double y = 2 [default = 0];
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Position::y() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.y)
  return y_;
}
inline void Position::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.y)
}

// optional double z = 3 [default = 0];
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Position::z() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.z)
  return z_;
}
inline void Position::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.z)
}

// -------------------------------------------------------------------

// Orentation

// optional double roll = 1 [default = 0];
inline bool Orentation::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orentation::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orentation::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orentation::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double Orentation::roll() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.roll)
  return roll_;
}
inline void Orentation::set_roll(double value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.roll)
}

// optional double pitch = 2 [default = 0];
inline bool Orentation::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orentation::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orentation::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orentation::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double Orentation::pitch() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.pitch)
  return pitch_;
}
inline void Orentation::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.pitch)
}

// required double yaw = 3 [default = 0];
inline bool Orentation::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orentation::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orentation::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orentation::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double Orentation::yaw() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.yaw)
  return yaw_;
}
inline void Orentation::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.yaw)
}

// -------------------------------------------------------------------

// Pose

// required .stdmsg.Position position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::stdmsg::Position::Clear();
  clear_has_position();
}
inline const ::stdmsg::Position& Pose::position() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::stdmsg::Position* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::stdmsg::Position;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.position)
  return position_;
}
inline ::stdmsg::Position* Pose::release_position() {
  clear_has_position();
  ::stdmsg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::stdmsg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.position)
}

// required .stdmsg.Orentation orentation = 2;
inline bool Pose::has_orentation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orentation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orentation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orentation() {
  if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
  clear_has_orentation();
}
inline const ::stdmsg::Orentation& Pose::orentation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.orentation)
  return orentation_ != NULL ? *orentation_ : *default_instance_->orentation_;
}
inline ::stdmsg::Orentation* Pose::mutable_orentation() {
  set_has_orentation();
  if (orentation_ == NULL) {
    orentation_ = new ::stdmsg::Orentation;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.orentation)
  return orentation_;
}
inline ::stdmsg::Orentation* Pose::release_orentation() {
  clear_has_orentation();
  ::stdmsg::Orentation* temp = orentation_;
  orentation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orentation(::stdmsg::Orentation* orentation) {
  delete orentation_;
  orentation_ = orentation;
  if (orentation) {
    set_has_orentation();
  } else {
    clear_has_orentation();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.orentation)
}

// -------------------------------------------------------------------

// Velocity

// required double v = 1 [default = 0];
inline bool Velocity::has_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Velocity::set_has_v() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Velocity::clear_has_v() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Velocity::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double Velocity::v() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.v)
  return v_;
}
inline void Velocity::set_v(double value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.v)
}

// required double w = 2 [default = 0];
inline bool Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Velocity::w() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.w)
  return w_;
}
inline void Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.w)
}

// optional double v2 = 3 [default = 0];
inline bool Velocity::has_v2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Velocity::set_has_v2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Velocity::clear_has_v2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Velocity::clear_v2() {
  v2_ = 0;
  clear_has_v2();
}
inline double Velocity::v2() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.v2)
  return v2_;
}
inline void Velocity::set_v2(double value) {
  set_has_v2();
  v2_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.v2)
}

// -------------------------------------------------------------------

// Pose_Velocity

// optional double x = 1 [default = 0];
inline bool Pose_Velocity::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose_Velocity::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose_Velocity::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose_Velocity::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Pose_Velocity::x() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.x)
  return x_;
}
inline void Pose_Velocity::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.x)
}

// optional double y = 2 [default = 0];
inline bool Pose_Velocity::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose_Velocity::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose_Velocity::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose_Velocity::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Pose_Velocity::y() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.y)
  return y_;
}
inline void Pose_Velocity::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.y)
}

// optional double yaw = 3 [default = 0];
inline bool Pose_Velocity::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pose_Velocity::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pose_Velocity::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pose_Velocity::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double Pose_Velocity::yaw() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.yaw)
  return yaw_;
}
inline void Pose_Velocity::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.yaw)
}

// required double vx = 4 [default = 0];
inline bool Pose_Velocity::has_vx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pose_Velocity::set_has_vx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pose_Velocity::clear_has_vx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pose_Velocity::clear_vx() {
  vx_ = 0;
  clear_has_vx();
}
inline double Pose_Velocity::vx() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.vx)
  return vx_;
}
inline void Pose_Velocity::set_vx(double value) {
  set_has_vx();
  vx_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.vx)
}

// required double vy = 5 [default = 0];
inline bool Pose_Velocity::has_vy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pose_Velocity::set_has_vy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pose_Velocity::clear_has_vy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pose_Velocity::clear_vy() {
  vy_ = 0;
  clear_has_vy();
}
inline double Pose_Velocity::vy() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.vy)
  return vy_;
}
inline void Pose_Velocity::set_vy(double value) {
  set_has_vy();
  vy_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.vy)
}

// required double w = 6 [default = 0];
inline bool Pose_Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pose_Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pose_Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pose_Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Pose_Velocity::w() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.w)
  return w_;
}
inline void Pose_Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.w)
}

// -------------------------------------------------------------------

// Laser_Scan_Laser_Config

// required float angle_min = 1;
inline bool Laser_Scan_Laser_Config::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Laser_Scan_Laser_Config::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
inline float Laser_Scan_Laser_Config::angle_min() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_min)
  return angle_min_;
}
inline void Laser_Scan_Laser_Config::set_angle_min(float value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_min)
}

// required float angle_max = 2;
inline bool Laser_Scan_Laser_Config::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Laser_Scan_Laser_Config::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
inline float Laser_Scan_Laser_Config::angle_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_max)
  return angle_max_;
}
inline void Laser_Scan_Laser_Config::set_angle_max(float value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_max)
}

// required float angle_increment = 3;
inline bool Laser_Scan_Laser_Config::has_angle_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_increment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Laser_Scan_Laser_Config::clear_angle_increment() {
  angle_increment_ = 0;
  clear_has_angle_increment();
}
inline float Laser_Scan_Laser_Config::angle_increment() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_increment)
  return angle_increment_;
}
inline void Laser_Scan_Laser_Config::set_angle_increment(float value) {
  set_has_angle_increment();
  angle_increment_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_increment)
}

// required float range_max = 5;
inline bool Laser_Scan_Laser_Config::has_range_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_range_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Laser_Scan_Laser_Config::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Laser_Scan_Laser_Config::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
inline float Laser_Scan_Laser_Config::range_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.range_max)
  return range_max_;
}
inline void Laser_Scan_Laser_Config::set_range_max(float value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.range_max)
}

// -------------------------------------------------------------------

// Laser_Scan

// required .stdmsg.Laser_Scan.Laser_Config config = 1;
inline bool Laser_Scan::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Laser_Scan::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Laser_Scan::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Laser_Scan::clear_config() {
  if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
  clear_has_config();
}
inline const ::stdmsg::Laser_Scan_Laser_Config& Laser_Scan::config() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::stdmsg::Laser_Scan_Laser_Config;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.config)
  return config_;
}
inline ::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::release_config() {
  clear_has_config();
  ::stdmsg::Laser_Scan_Laser_Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.config)
}

// repeated float ranges = 2;
inline int Laser_Scan::ranges_size() const {
  return ranges_.size();
}
inline void Laser_Scan::clear_ranges() {
  ranges_.Clear();
}
inline float Laser_Scan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.ranges)
  return ranges_.Get(index);
}
inline void Laser_Scan::set_ranges(int index, float value) {
  ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.ranges)
}
inline void Laser_Scan::add_ranges(float value) {
  ranges_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.ranges)
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.ranges)
  return &ranges_;
}

// repeated float intensities = 3;
inline int Laser_Scan::intensities_size() const {
  return intensities_.size();
}
inline void Laser_Scan::clear_intensities() {
  intensities_.Clear();
}
inline float Laser_Scan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.intensities)
  return intensities_.Get(index);
}
inline void Laser_Scan::set_intensities(int index, float value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.intensities)
}
inline void Laser_Scan::add_intensities(float value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.intensities)
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::intensities() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.intensities)
  return intensities_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.intensities)
  return &intensities_;
}

// required .stdmsg.Pose pose = 5;
inline bool Laser_Scan::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Laser_Scan::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Laser_Scan::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Laser_Scan::clear_pose() {
  if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
  clear_has_pose();
}
inline const ::stdmsg::Pose& Laser_Scan::pose() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::stdmsg::Pose* Laser_Scan::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.pose)
  return pose_;
}
inline ::stdmsg::Pose* Laser_Scan::release_pose() {
  clear_has_pose();
  ::stdmsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_pose(::stdmsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.pose)
}

// required .stdmsg.Pose robot = 6;
inline bool Laser_Scan::has_robot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Laser_Scan::set_has_robot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Laser_Scan::clear_has_robot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Laser_Scan::clear_robot() {
  if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
  clear_has_robot();
}
inline const ::stdmsg::Pose& Laser_Scan::robot() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::stdmsg::Pose* Laser_Scan::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    robot_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.robot)
  return robot_;
}
inline ::stdmsg::Pose* Laser_Scan::release_robot() {
  clear_has_robot();
  ::stdmsg::Pose* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_robot(::stdmsg::Pose* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.robot)
}

// optional double steer = 9;
inline bool Laser_Scan::has_steer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Laser_Scan::set_has_steer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Laser_Scan::clear_has_steer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Laser_Scan::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
inline double Laser_Scan::steer() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.steer)
  return steer_;
}
inline void Laser_Scan::set_steer(double value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.steer)
}

// optional int32 seq = 7 [default = 0];
inline bool Laser_Scan::has_seq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Laser_Scan::set_has_seq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Laser_Scan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Laser_Scan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Laser_Scan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.seq)
  return seq_;
}
inline void Laser_Scan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.seq)
}

// optional string annotation = 8 [default = ""];
inline bool Laser_Scan::has_annotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Laser_Scan::set_has_annotation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Laser_Scan::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Laser_Scan::clear_annotation() {
  annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_annotation();
}
inline const ::std::string& Laser_Scan::annotation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.annotation)
  return annotation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Laser_Scan::set_annotation(const ::std::string& value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.annotation)
}
inline void Laser_Scan::set_annotation(const char* value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Laser_Scan.annotation)
}
inline void Laser_Scan::set_annotation(const char* value, size_t size) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Laser_Scan.annotation)
}
inline ::std::string* Laser_Scan::mutable_annotation() {
  set_has_annotation();
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.annotation)
  return annotation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Laser_Scan::release_annotation() {
  clear_has_annotation();
  return annotation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Laser_Scan::set_allocated_annotation(::std::string* annotation) {
  if (annotation != NULL) {
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
  annotation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotation);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.annotation)
}

// -------------------------------------------------------------------

// Global_Plan

// repeated .stdmsg.Pose path = 1;
inline int Global_Plan::path_size() const {
  return path_.size();
}
inline void Global_Plan::clear_path() {
  path_.Clear();
}
inline const ::stdmsg::Pose& Global_Plan::path(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.path)
  return path_.Get(index);
}
inline ::stdmsg::Pose* Global_Plan::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Global_Plan.path)
  return path_.Mutable(index);
}
inline ::stdmsg::Pose* Global_Plan::add_path() {
  // @@protoc_insertion_point(field_add:stdmsg.Global_Plan.path)
  return path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
Global_Plan::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Global_Plan.path)
  return &path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
Global_Plan::path() const {
  // @@protoc_insertion_point(field_list:stdmsg.Global_Plan.path)
  return path_;
}

// optional int32 seq = 2 [default = 0];
inline bool Global_Plan::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Global_Plan::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Global_Plan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Global_Plan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Global_Plan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.seq)
  return seq_;
}
inline void Global_Plan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.seq)
}

// optional int32 goal_reached = 3 [default = 0];
inline bool Global_Plan::has_goal_reached() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Global_Plan::set_has_goal_reached() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Global_Plan::clear_has_goal_reached() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Global_Plan::clear_goal_reached() {
  goal_reached_ = 0;
  clear_has_goal_reached();
}
inline ::google::protobuf::int32 Global_Plan::goal_reached() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.goal_reached)
  return goal_reached_;
}
inline void Global_Plan::set_goal_reached(::google::protobuf::int32 value) {
  set_has_goal_reached();
  goal_reached_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.goal_reached)
}

// optional int32 distance_goal_reached = 4 [default = 0];
inline bool Global_Plan::has_distance_goal_reached() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Global_Plan::set_has_distance_goal_reached() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Global_Plan::clear_has_distance_goal_reached() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Global_Plan::clear_distance_goal_reached() {
  distance_goal_reached_ = 0;
  clear_has_distance_goal_reached();
}
inline ::google::protobuf::int32 Global_Plan::distance_goal_reached() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.distance_goal_reached)
  return distance_goal_reached_;
}
inline void Global_Plan::set_distance_goal_reached(::google::protobuf::int32 value) {
  set_has_distance_goal_reached();
  distance_goal_reached_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.distance_goal_reached)
}

// -------------------------------------------------------------------

// Data

// optional bytes data = 1 [default = ""];
inline bool Data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Data::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Data.data)
}
inline void Data::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Data.data)
}
inline void Data::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Data.data)
}
inline ::std::string* Data::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:stdmsg.Data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Data::release_data() {
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Data.data)
}

// optional int32 seq = 2 [default = 0];
inline bool Data::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Data::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.seq)
  return seq_;
}
inline void Data::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Data.seq)
}

// -------------------------------------------------------------------

// String

// optional string str = 1 [default = ""];
inline bool String::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void String::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void String::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void String::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
inline const ::std::string& String::str() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.str)
  return str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.String.str)
}
inline void String::set_str(const char* value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.String.str)
}
inline void String::set_str(const char* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.String.str)
}
inline ::std::string* String::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:stdmsg.String.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* String::release_str() {
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.String.str)
}

// optional int32 seq = 2 [default = 0];
inline bool String::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void String::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void String::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void String::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 String::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.seq)
  return seq_;
}
inline void String::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.String.seq)
}

// -------------------------------------------------------------------

// LaserList

// repeated .stdmsg.Laser_Scan scans = 1;
inline int LaserList::scans_size() const {
  return scans_.size();
}
inline void LaserList::clear_scans() {
  scans_.Clear();
}
inline const ::stdmsg::Laser_Scan& LaserList::scans(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.scans)
  return scans_.Get(index);
}
inline ::stdmsg::Laser_Scan* LaserList::mutable_scans(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.LaserList.scans)
  return scans_.Mutable(index);
}
inline ::stdmsg::Laser_Scan* LaserList::add_scans() {
  // @@protoc_insertion_point(field_add:stdmsg.LaserList.scans)
  return scans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
LaserList::mutable_scans() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.LaserList.scans)
  return &scans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
LaserList::scans() const {
  // @@protoc_insertion_point(field_list:stdmsg.LaserList.scans)
  return scans_;
}

// optional int32 seq = 2 [default = 0];
inline bool LaserList::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaserList::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaserList::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaserList::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 LaserList::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.seq)
  return seq_;
}
inline void LaserList::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.LaserList.seq)
}

// -------------------------------------------------------------------

// MoveMode

// required int32 move_mode = 1 [default = 0];
inline bool MoveMode::has_move_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveMode::set_has_move_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveMode::clear_has_move_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveMode::clear_move_mode() {
  move_mode_ = 0;
  clear_has_move_mode();
}
inline ::google::protobuf::int32 MoveMode::move_mode() const {
  // @@protoc_insertion_point(field_get:stdmsg.MoveMode.move_mode)
  return move_mode_;
}
inline void MoveMode::set_move_mode(::google::protobuf::int32 value) {
  set_has_move_mode();
  move_mode_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.MoveMode.move_mode)
}

// -------------------------------------------------------------------

// SomeFlag

// optional int32 emergency_stop_flag = 1;
inline bool SomeFlag::has_emergency_stop_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SomeFlag::set_has_emergency_stop_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SomeFlag::clear_has_emergency_stop_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SomeFlag::clear_emergency_stop_flag() {
  emergency_stop_flag_ = 0;
  clear_has_emergency_stop_flag();
}
inline ::google::protobuf::int32 SomeFlag::emergency_stop_flag() const {
  // @@protoc_insertion_point(field_get:stdmsg.SomeFlag.emergency_stop_flag)
  return emergency_stop_flag_;
}
inline void SomeFlag::set_emergency_stop_flag(::google::protobuf::int32 value) {
  set_has_emergency_stop_flag();
  emergency_stop_flag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.SomeFlag.emergency_stop_flag)
}

// optional int32 obstacle_forward_flag = 2;
inline bool SomeFlag::has_obstacle_forward_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SomeFlag::set_has_obstacle_forward_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SomeFlag::clear_has_obstacle_forward_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SomeFlag::clear_obstacle_forward_flag() {
  obstacle_forward_flag_ = 0;
  clear_has_obstacle_forward_flag();
}
inline ::google::protobuf::int32 SomeFlag::obstacle_forward_flag() const {
  // @@protoc_insertion_point(field_get:stdmsg.SomeFlag.obstacle_forward_flag)
  return obstacle_forward_flag_;
}
inline void SomeFlag::set_obstacle_forward_flag(::google::protobuf::int32 value) {
  set_has_obstacle_forward_flag();
  obstacle_forward_flag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.SomeFlag.obstacle_forward_flag)
}

// optional int32 move_mode_flag = 3;
inline bool SomeFlag::has_move_mode_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SomeFlag::set_has_move_mode_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SomeFlag::clear_has_move_mode_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SomeFlag::clear_move_mode_flag() {
  move_mode_flag_ = 0;
  clear_has_move_mode_flag();
}
inline ::google::protobuf::int32 SomeFlag::move_mode_flag() const {
  // @@protoc_insertion_point(field_get:stdmsg.SomeFlag.move_mode_flag)
  return move_mode_flag_;
}
inline void SomeFlag::set_move_mode_flag(::google::protobuf::int32 value) {
  set_has_move_mode_flag();
  move_mode_flag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.SomeFlag.move_mode_flag)
}

// -------------------------------------------------------------------

// NavConfig

// optional double stop_delta_distance = 1;
inline bool NavConfig::has_stop_delta_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavConfig::set_has_stop_delta_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavConfig::clear_has_stop_delta_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavConfig::clear_stop_delta_distance() {
  stop_delta_distance_ = 0;
  clear_has_stop_delta_distance();
}
inline double NavConfig::stop_delta_distance() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.stop_delta_distance)
  return stop_delta_distance_;
}
inline void NavConfig::set_stop_delta_distance(double value) {
  set_has_stop_delta_distance();
  stop_delta_distance_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.stop_delta_distance)
}

// optional double stop_delta_theta = 2;
inline bool NavConfig::has_stop_delta_theta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavConfig::set_has_stop_delta_theta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavConfig::clear_has_stop_delta_theta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavConfig::clear_stop_delta_theta() {
  stop_delta_theta_ = 0;
  clear_has_stop_delta_theta();
}
inline double NavConfig::stop_delta_theta() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.stop_delta_theta)
  return stop_delta_theta_;
}
inline void NavConfig::set_stop_delta_theta(double value) {
  set_has_stop_delta_theta();
  stop_delta_theta_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.stop_delta_theta)
}

// optional double nav_v = 3;
inline bool NavConfig::has_nav_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NavConfig::set_has_nav_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NavConfig::clear_has_nav_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NavConfig::clear_nav_v() {
  nav_v_ = 0;
  clear_has_nav_v();
}
inline double NavConfig::nav_v() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.nav_v)
  return nav_v_;
}
inline void NavConfig::set_nav_v(double value) {
  set_has_nav_v();
  nav_v_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.nav_v)
}

// optional double nav_w = 4;
inline bool NavConfig::has_nav_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NavConfig::set_has_nav_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NavConfig::clear_has_nav_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NavConfig::clear_nav_w() {
  nav_w_ = 0;
  clear_has_nav_w();
}
inline double NavConfig::nav_w() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.nav_w)
  return nav_w_;
}
inline void NavConfig::set_nav_w(double value) {
  set_has_nav_w();
  nav_w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.nav_w)
}

// -------------------------------------------------------------------

// Light

// optional int32 lightflag = 1;
inline bool Light::has_lightflag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light::set_has_lightflag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light::clear_has_lightflag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light::clear_lightflag() {
  lightflag_ = 0;
  clear_has_lightflag();
}
inline ::google::protobuf::int32 Light::lightflag() const {
  // @@protoc_insertion_point(field_get:stdmsg.Light.lightflag)
  return lightflag_;
}
inline void Light::set_lightflag(::google::protobuf::int32 value) {
  set_has_lightflag();
  lightflag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Light.lightflag)
}

// optional int32 number = 2;
inline bool Light::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 Light::number() const {
  // @@protoc_insertion_point(field_get:stdmsg.Light.number)
  return number_;
}
inline void Light::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Light.number)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace stdmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_stdmsg_2eproto__INCLUDED
