// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stdmsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "stdmsg.hh"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace stdmsg {

namespace {

const ::google::protobuf::Descriptor* Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Position_reflection_ = NULL;
const ::google::protobuf::Descriptor* Orentation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Orentation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pose_reflection_ = NULL;
const ::google::protobuf::Descriptor* Velocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Velocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pose_Velocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pose_Velocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Laser_Scan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Laser_Scan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Laser_Scan_Laser_Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Laser_Scan_Laser_Config_reflection_ = NULL;
const ::google::protobuf::Descriptor* Global_Plan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Global_Plan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Data_reflection_ = NULL;
const ::google::protobuf::Descriptor* String_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  String_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaserList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaserList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MoveMode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MoveMode_reflection_ = NULL;
const ::google::protobuf::Descriptor* SomeFlag_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SomeFlag_reflection_ = NULL;
const ::google::protobuf::Descriptor* NavConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NavConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* Light_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Light_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_stdmsg_2eproto() {
  protobuf_AddDesc_stdmsg_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "stdmsg.proto");
  GOOGLE_CHECK(file != NULL);
  Position_descriptor_ = file->message_type(0);
  static const int Position_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, z_),
  };
  Position_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Position_descriptor_,
      Position::default_instance_,
      Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _has_bits_[0]),
      -1,
      -1,
      sizeof(Position),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _internal_metadata_),
      -1);
  Orentation_descriptor_ = file->message_type(1);
  static const int Orentation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, roll_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, pitch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, yaw_),
  };
  Orentation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Orentation_descriptor_,
      Orentation::default_instance_,
      Orentation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, _has_bits_[0]),
      -1,
      -1,
      sizeof(Orentation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, _internal_metadata_),
      -1);
  Pose_descriptor_ = file->message_type(2);
  static const int Pose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, orentation_),
  };
  Pose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pose_descriptor_,
      Pose::default_instance_,
      Pose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _has_bits_[0]),
      -1,
      -1,
      sizeof(Pose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _internal_metadata_),
      -1);
  Velocity_descriptor_ = file->message_type(3);
  static const int Velocity_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, w_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, v2_),
  };
  Velocity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Velocity_descriptor_,
      Velocity::default_instance_,
      Velocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _has_bits_[0]),
      -1,
      -1,
      sizeof(Velocity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _internal_metadata_),
      -1);
  Pose_Velocity_descriptor_ = file->message_type(4);
  static const int Pose_Velocity_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, yaw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, vx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, vy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, w_),
  };
  Pose_Velocity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pose_Velocity_descriptor_,
      Pose_Velocity::default_instance_,
      Pose_Velocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, _has_bits_[0]),
      -1,
      -1,
      sizeof(Pose_Velocity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose_Velocity, _internal_metadata_),
      -1);
  Laser_Scan_descriptor_ = file->message_type(5);
  static const int Laser_Scan_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, intensities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, steer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, annotation_),
  };
  Laser_Scan_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Laser_Scan_descriptor_,
      Laser_Scan::default_instance_,
      Laser_Scan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, _has_bits_[0]),
      -1,
      -1,
      sizeof(Laser_Scan),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, _internal_metadata_),
      -1);
  Laser_Scan_Laser_Config_descriptor_ = Laser_Scan_descriptor_->nested_type(0);
  static const int Laser_Scan_Laser_Config_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, angle_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, angle_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, angle_increment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, range_max_),
  };
  Laser_Scan_Laser_Config_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Laser_Scan_Laser_Config_descriptor_,
      Laser_Scan_Laser_Config::default_instance_,
      Laser_Scan_Laser_Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, _has_bits_[0]),
      -1,
      -1,
      sizeof(Laser_Scan_Laser_Config),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, _internal_metadata_),
      -1);
  Global_Plan_descriptor_ = file->message_type(6);
  static const int Global_Plan_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, goal_reached_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, distance_goal_reached_),
  };
  Global_Plan_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Global_Plan_descriptor_,
      Global_Plan::default_instance_,
      Global_Plan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, _has_bits_[0]),
      -1,
      -1,
      sizeof(Global_Plan),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, _internal_metadata_),
      -1);
  Data_descriptor_ = file->message_type(7);
  static const int Data_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, seq_),
  };
  Data_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Data_descriptor_,
      Data::default_instance_,
      Data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _has_bits_[0]),
      -1,
      -1,
      sizeof(Data),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _internal_metadata_),
      -1);
  String_descriptor_ = file->message_type(8);
  static const int String_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, str_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, seq_),
  };
  String_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      String_descriptor_,
      String::default_instance_,
      String_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, _has_bits_[0]),
      -1,
      -1,
      sizeof(String),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, _internal_metadata_),
      -1);
  LaserList_descriptor_ = file->message_type(9);
  static const int LaserList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, scans_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, seq_),
  };
  LaserList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaserList_descriptor_,
      LaserList::default_instance_,
      LaserList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaserList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, _internal_metadata_),
      -1);
  MoveMode_descriptor_ = file->message_type(10);
  static const int MoveMode_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveMode, move_mode_),
  };
  MoveMode_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MoveMode_descriptor_,
      MoveMode::default_instance_,
      MoveMode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveMode, _has_bits_[0]),
      -1,
      -1,
      sizeof(MoveMode),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveMode, _internal_metadata_),
      -1);
  SomeFlag_descriptor_ = file->message_type(11);
  static const int SomeFlag_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SomeFlag, emergency_stop_flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SomeFlag, obstacle_forward_flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SomeFlag, move_mode_flag_),
  };
  SomeFlag_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SomeFlag_descriptor_,
      SomeFlag::default_instance_,
      SomeFlag_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SomeFlag, _has_bits_[0]),
      -1,
      -1,
      sizeof(SomeFlag),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SomeFlag, _internal_metadata_),
      -1);
  NavConfig_descriptor_ = file->message_type(12);
  static const int NavConfig_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavConfig, stop_delta_distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavConfig, stop_delta_theta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavConfig, nav_v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavConfig, nav_w_),
  };
  NavConfig_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NavConfig_descriptor_,
      NavConfig::default_instance_,
      NavConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavConfig, _has_bits_[0]),
      -1,
      -1,
      sizeof(NavConfig),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavConfig, _internal_metadata_),
      -1);
  Light_descriptor_ = file->message_type(13);
  static const int Light_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Light, lightflag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Light, number_),
  };
  Light_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Light_descriptor_,
      Light::default_instance_,
      Light_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Light, _has_bits_[0]),
      -1,
      -1,
      sizeof(Light),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Light, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_stdmsg_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Position_descriptor_, &Position::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Orentation_descriptor_, &Orentation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pose_descriptor_, &Pose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Velocity_descriptor_, &Velocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pose_Velocity_descriptor_, &Pose_Velocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Laser_Scan_descriptor_, &Laser_Scan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Laser_Scan_Laser_Config_descriptor_, &Laser_Scan_Laser_Config::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Global_Plan_descriptor_, &Global_Plan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Data_descriptor_, &Data::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      String_descriptor_, &String::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaserList_descriptor_, &LaserList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MoveMode_descriptor_, &MoveMode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SomeFlag_descriptor_, &SomeFlag::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NavConfig_descriptor_, &NavConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Light_descriptor_, &Light::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_stdmsg_2eproto() {
  delete Position::default_instance_;
  delete Position_reflection_;
  delete Orentation::default_instance_;
  delete Orentation_reflection_;
  delete Pose::default_instance_;
  delete Pose_reflection_;
  delete Velocity::default_instance_;
  delete Velocity_reflection_;
  delete Pose_Velocity::default_instance_;
  delete Pose_Velocity_reflection_;
  delete Laser_Scan::default_instance_;
  delete Laser_Scan_reflection_;
  delete Laser_Scan_Laser_Config::default_instance_;
  delete Laser_Scan_Laser_Config_reflection_;
  delete Global_Plan::default_instance_;
  delete Global_Plan_reflection_;
  delete Data::default_instance_;
  delete Data_reflection_;
  delete String::default_instance_;
  delete String_reflection_;
  delete LaserList::default_instance_;
  delete LaserList_reflection_;
  delete MoveMode::default_instance_;
  delete MoveMode_reflection_;
  delete SomeFlag::default_instance_;
  delete SomeFlag_reflection_;
  delete NavConfig::default_instance_;
  delete NavConfig_reflection_;
  delete Light::default_instance_;
  delete Light_reflection_;
}

void protobuf_AddDesc_stdmsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014stdmsg.proto\022\006stdmsg\"4\n\010Position\022\014\n\001x\030"
    "\001 \002(\001:\0010\022\014\n\001y\030\002 \002(\001:\0010\022\014\n\001z\030\003 \001(\001:\0010\"\?\n\n"
    "Orentation\022\017\n\004roll\030\001 \001(\001:\0010\022\020\n\005pitch\030\002 \001"
    "(\001:\0010\022\016\n\003yaw\030\003 \002(\001:\0010\"R\n\004Pose\022\"\n\010positio"
    "n\030\001 \002(\0132\020.stdmsg.Position\022&\n\norentation\030"
    "\002 \002(\0132\022.stdmsg.Orentation\"5\n\010Velocity\022\014\n"
    "\001v\030\001 \002(\001:\0010\022\014\n\001w\030\002 \002(\001:\0010\022\r\n\002v2\030\003 \001(\001:\0010"
    "\"g\n\rPose_Velocity\022\014\n\001x\030\001 \001(\001:\0010\022\014\n\001y\030\002 \001"
    "(\001:\0010\022\016\n\003yaw\030\003 \001(\001:\0010\022\r\n\002vx\030\004 \002(\001:\0010\022\r\n\002"
    "vy\030\005 \002(\001:\0010\022\014\n\001w\030\006 \002(\001:\0010\"\262\002\n\nLaser_Scan"
    "\022/\n\006config\030\001 \002(\0132\037.stdmsg.Laser_Scan.Las"
    "er_Config\022\016\n\006ranges\030\002 \003(\002\022\023\n\013intensities"
    "\030\003 \003(\002\022\032\n\004pose\030\005 \002(\0132\014.stdmsg.Pose\022\033\n\005ro"
    "bot\030\006 \002(\0132\014.stdmsg.Pose\022\r\n\005steer\030\t \001(\001\022\016"
    "\n\003seq\030\007 \001(\005:\0010\022\024\n\nannotation\030\010 \001(\t:\000\032`\n\014"
    "Laser_Config\022\021\n\tangle_min\030\001 \002(\002\022\021\n\tangle"
    "_max\030\002 \002(\002\022\027\n\017angle_increment\030\003 \002(\002\022\021\n\tr"
    "ange_max\030\005 \002(\002\"t\n\013Global_Plan\022\032\n\004path\030\001 "
    "\003(\0132\014.stdmsg.Pose\022\016\n\003seq\030\002 \001(\005:\0010\022\027\n\014goa"
    "l_reached\030\003 \001(\005:\0010\022 \n\025distance_goal_reac"
    "hed\030\004 \001(\005:\0010\"&\n\004Data\022\016\n\004data\030\001 \001(\014:\000\022\016\n\003"
    "seq\030\002 \001(\005:\0010\"\'\n\006String\022\r\n\003str\030\001 \001(\t:\000\022\016\n"
    "\003seq\030\002 \001(\005:\0010\">\n\tLaserList\022!\n\005scans\030\001 \003("
    "\0132\022.stdmsg.Laser_Scan\022\016\n\003seq\030\002 \001(\005:\0010\" \n"
    "\010MoveMode\022\024\n\tmove_mode\030\001 \002(\005:\0010\"^\n\010SomeF"
    "lag\022\033\n\023emergency_stop_flag\030\001 \001(\005\022\035\n\025obst"
    "acle_forward_flag\030\002 \001(\005\022\026\n\016move_mode_fla"
    "g\030\003 \001(\005\"`\n\tNavConfig\022\033\n\023stop_delta_dista"
    "nce\030\001 \001(\001\022\030\n\020stop_delta_theta\030\002 \001(\001\022\r\n\005n"
    "av_v\030\003 \001(\001\022\r\n\005nav_w\030\004 \001(\001\"*\n\005Light\022\021\n\tli"
    "ghtflag\030\001 \001(\005\022\016\n\006number\030\002 \001(\005", 1229);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "stdmsg.proto", &protobuf_RegisterTypes);
  Position::default_instance_ = new Position();
  Orentation::default_instance_ = new Orentation();
  Pose::default_instance_ = new Pose();
  Velocity::default_instance_ = new Velocity();
  Pose_Velocity::default_instance_ = new Pose_Velocity();
  Laser_Scan::default_instance_ = new Laser_Scan();
  Laser_Scan_Laser_Config::default_instance_ = new Laser_Scan_Laser_Config();
  Global_Plan::default_instance_ = new Global_Plan();
  Data::default_instance_ = new Data();
  String::default_instance_ = new String();
  LaserList::default_instance_ = new LaserList();
  MoveMode::default_instance_ = new MoveMode();
  SomeFlag::default_instance_ = new SomeFlag();
  NavConfig::default_instance_ = new NavConfig();
  Light::default_instance_ = new Light();
  Position::default_instance_->InitAsDefaultInstance();
  Orentation::default_instance_->InitAsDefaultInstance();
  Pose::default_instance_->InitAsDefaultInstance();
  Velocity::default_instance_->InitAsDefaultInstance();
  Pose_Velocity::default_instance_->InitAsDefaultInstance();
  Laser_Scan::default_instance_->InitAsDefaultInstance();
  Laser_Scan_Laser_Config::default_instance_->InitAsDefaultInstance();
  Global_Plan::default_instance_->InitAsDefaultInstance();
  Data::default_instance_->InitAsDefaultInstance();
  String::default_instance_->InitAsDefaultInstance();
  LaserList::default_instance_->InitAsDefaultInstance();
  MoveMode::default_instance_->InitAsDefaultInstance();
  SomeFlag::default_instance_->InitAsDefaultInstance();
  NavConfig::default_instance_->InitAsDefaultInstance();
  Light::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_stdmsg_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_stdmsg_2eproto {
  StaticDescriptorInitializer_stdmsg_2eproto() {
    protobuf_AddDesc_stdmsg_2eproto();
  }
} static_descriptor_initializer_stdmsg_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Position::kXFieldNumber;
const int Position::kYFieldNumber;
const int Position::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Position::Position()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Position)
}

void Position::InitAsDefaultInstance() {
}

Position::Position(const Position& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Position)
}

void Position::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:stdmsg.Position)
  SharedDtor();
}

void Position::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Position_descriptor_;
}

const Position& Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Position* Position::default_instance_ = NULL;

Position* Position::New(::google::protobuf::Arena* arena) const {
  Position* n = new Position;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Position::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Position*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3 [default = 0];
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Position)
  return false;
#undef DO_
}

void Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Position)
  // required double x = 1 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2 [default = 0];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Position)
}

::google::protobuf::uint8* Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Position)
  // required double x = 1 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2 [default = 0];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Position)
  return target;
}

int Position::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required double x = 1 [default = 0];
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2 [default = 0];
    total_size += 1 + 8;
  }

  return total_size;
}
int Position::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double x = 1 [default = 0];
    total_size += 1 + 8;

    // required double y = 2 [default = 0];
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional double z = 3 [default = 0];
  if (has_z()) {
    total_size += 1 + 8;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Position::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Position* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Position>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Position::MergeFrom(const Position& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Position::CopyFrom(const Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Position::Swap(Position* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Position::InternalSwap(Position* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Position_descriptor_;
  metadata.reflection = Position_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// required double x = 1 [default = 0];
bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Position::x() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.x)
  return x_;
}
 void Position::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.x)
}

// required double y = 2 [default = 0];
bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Position::y() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.y)
  return y_;
}
 void Position::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.y)
}

// optional double z = 3 [default = 0];
bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Position::z() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.z)
  return z_;
}
 void Position::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Orentation::kRollFieldNumber;
const int Orentation::kPitchFieldNumber;
const int Orentation::kYawFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Orentation::Orentation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Orentation)
}

void Orentation::InitAsDefaultInstance() {
}

Orentation::Orentation(const Orentation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Orentation)
}

void Orentation::SharedCtor() {
  _cached_size_ = 0;
  roll_ = 0;
  pitch_ = 0;
  yaw_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Orentation::~Orentation() {
  // @@protoc_insertion_point(destructor:stdmsg.Orentation)
  SharedDtor();
}

void Orentation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Orentation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Orentation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Orentation_descriptor_;
}

const Orentation& Orentation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Orentation* Orentation::default_instance_ = NULL;

Orentation* Orentation::New(::google::protobuf::Arena* arena) const {
  Orentation* n = new Orentation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Orentation::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Orentation*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(roll_, yaw_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Orentation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Orentation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double roll = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roll_)));
          set_has_roll();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_pitch;
        break;
      }

      // optional double pitch = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_pitch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &pitch_)));
          set_has_pitch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_yaw;
        break;
      }

      // required double yaw = 3 [default = 0];
      case 3: {
        if (tag == 25) {
         parse_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Orentation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Orentation)
  return false;
#undef DO_
}

void Orentation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Orentation)
  // optional double roll = 1 [default = 0];
  if (has_roll()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->roll(), output);
  }

  // optional double pitch = 2 [default = 0];
  if (has_pitch()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->pitch(), output);
  }

  // required double yaw = 3 [default = 0];
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->yaw(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Orentation)
}

::google::protobuf::uint8* Orentation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Orentation)
  // optional double roll = 1 [default = 0];
  if (has_roll()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->roll(), target);
  }

  // optional double pitch = 2 [default = 0];
  if (has_pitch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->pitch(), target);
  }

  // required double yaw = 3 [default = 0];
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->yaw(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Orentation)
  return target;
}

int Orentation::ByteSize() const {
  int total_size = 0;

  // required double yaw = 3 [default = 0];
  if (has_yaw()) {
    total_size += 1 + 8;
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional double roll = 1 [default = 0];
    if (has_roll()) {
      total_size += 1 + 8;
    }

    // optional double pitch = 2 [default = 0];
    if (has_pitch()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Orentation::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Orentation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Orentation>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Orentation::MergeFrom(const Orentation& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roll()) {
      set_roll(from.roll());
    }
    if (from.has_pitch()) {
      set_pitch(from.pitch());
    }
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Orentation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Orentation::CopyFrom(const Orentation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Orentation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void Orentation::Swap(Orentation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Orentation::InternalSwap(Orentation* other) {
  std::swap(roll_, other->roll_);
  std::swap(pitch_, other->pitch_);
  std::swap(yaw_, other->yaw_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Orentation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Orentation_descriptor_;
  metadata.reflection = Orentation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Orentation

// optional double roll = 1 [default = 0];
bool Orentation::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Orentation::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
void Orentation::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
void Orentation::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
 double Orentation::roll() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.roll)
  return roll_;
}
 void Orentation::set_roll(double value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.roll)
}

// optional double pitch = 2 [default = 0];
bool Orentation::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Orentation::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
void Orentation::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
void Orentation::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
 double Orentation::pitch() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.pitch)
  return pitch_;
}
 void Orentation::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.pitch)
}

// required double yaw = 3 [default = 0];
bool Orentation::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Orentation::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
void Orentation::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
void Orentation::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
 double Orentation::yaw() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.yaw)
  return yaw_;
}
 void Orentation::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.yaw)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose::kPositionFieldNumber;
const int Pose::kOrentationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose::Pose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Pose)
}

void Pose::InitAsDefaultInstance() {
  position_ = const_cast< ::stdmsg::Position*>(&::stdmsg::Position::default_instance());
  orentation_ = const_cast< ::stdmsg::Orentation*>(&::stdmsg::Orentation::default_instance());
}

Pose::Pose(const Pose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Pose)
}

void Pose::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  orentation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:stdmsg.Pose)
  SharedDtor();
}

void Pose::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete orentation_;
  }
}

void Pose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pose_descriptor_;
}

const Pose& Pose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Pose* Pose::default_instance_ = NULL;

Pose* Pose::New(::google::protobuf::Arena* arena) const {
  Pose* n = new Pose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_position()) {
      if (position_ != NULL) position_->::stdmsg::Position::Clear();
    }
    if (has_orentation()) {
      if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Pose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Pose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .stdmsg.Position position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orentation;
        break;
      }

      // required .stdmsg.Orentation orentation = 2;
      case 2: {
        if (tag == 18) {
         parse_orentation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orentation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Pose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Pose)
  return false;
#undef DO_
}

void Pose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Pose)
  // required .stdmsg.Position position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // required .stdmsg.Orentation orentation = 2;
  if (has_orentation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orentation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Pose)
}

::google::protobuf::uint8* Pose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Pose)
  // required .stdmsg.Position position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->position_, target);
  }

  // required .stdmsg.Orentation orentation = 2;
  if (has_orentation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->orentation_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Pose)
  return target;
}

int Pose::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_position()) {
    // required .stdmsg.Position position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  if (has_orentation()) {
    // required .stdmsg.Orentation orentation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orentation_);
  }

  return total_size;
}
int Pose::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .stdmsg.Position position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

    // required .stdmsg.Orentation orentation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orentation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Pose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Pose::MergeFrom(const Pose& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::stdmsg::Position::MergeFrom(from.position());
    }
    if (from.has_orentation()) {
      mutable_orentation()->::stdmsg::Orentation::MergeFrom(from.orentation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Pose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose::CopyFrom(const Pose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  if (has_orentation()) {
    if (!this->orentation_->IsInitialized()) return false;
  }
  return true;
}

void Pose::Swap(Pose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose::InternalSwap(Pose* other) {
  std::swap(position_, other->position_);
  std::swap(orentation_, other->orentation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pose_descriptor_;
  metadata.reflection = Pose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose

// required .stdmsg.Position position = 1;
bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void Pose::clear_position() {
  if (position_ != NULL) position_->::stdmsg::Position::Clear();
  clear_has_position();
}
const ::stdmsg::Position& Pose::position() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::stdmsg::Position* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::stdmsg::Position;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.position)
  return position_;
}
::stdmsg::Position* Pose::release_position() {
  clear_has_position();
  ::stdmsg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
void Pose::set_allocated_position(::stdmsg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.position)
}

// required .stdmsg.Orentation orentation = 2;
bool Pose::has_orentation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Pose::set_has_orentation() {
  _has_bits_[0] |= 0x00000002u;
}
void Pose::clear_has_orentation() {
  _has_bits_[0] &= ~0x00000002u;
}
void Pose::clear_orentation() {
  if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
  clear_has_orentation();
}
const ::stdmsg::Orentation& Pose::orentation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.orentation)
  return orentation_ != NULL ? *orentation_ : *default_instance_->orentation_;
}
::stdmsg::Orentation* Pose::mutable_orentation() {
  set_has_orentation();
  if (orentation_ == NULL) {
    orentation_ = new ::stdmsg::Orentation;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.orentation)
  return orentation_;
}
::stdmsg::Orentation* Pose::release_orentation() {
  clear_has_orentation();
  ::stdmsg::Orentation* temp = orentation_;
  orentation_ = NULL;
  return temp;
}
void Pose::set_allocated_orentation(::stdmsg::Orentation* orentation) {
  delete orentation_;
  orentation_ = orentation;
  if (orentation) {
    set_has_orentation();
  } else {
    clear_has_orentation();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.orentation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Velocity::kVFieldNumber;
const int Velocity::kWFieldNumber;
const int Velocity::kV2FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Velocity::Velocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Velocity)
}

void Velocity::InitAsDefaultInstance() {
}

Velocity::Velocity(const Velocity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Velocity)
}

void Velocity::SharedCtor() {
  _cached_size_ = 0;
  v_ = 0;
  w_ = 0;
  v2_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Velocity::~Velocity() {
  // @@protoc_insertion_point(destructor:stdmsg.Velocity)
  SharedDtor();
}

void Velocity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Velocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Velocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Velocity_descriptor_;
}

const Velocity& Velocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Velocity* Velocity::default_instance_ = NULL;

Velocity* Velocity::New(::google::protobuf::Arena* arena) const {
  Velocity* n = new Velocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Velocity::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Velocity*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(v_, v2_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Velocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Velocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double v = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &v_)));
          set_has_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_w;
        break;
      }

      // required double w = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_v2;
        break;
      }

      // optional double v2 = 3 [default = 0];
      case 3: {
        if (tag == 25) {
         parse_v2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &v2_)));
          set_has_v2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Velocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Velocity)
  return false;
#undef DO_
}

void Velocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Velocity)
  // required double v = 1 [default = 0];
  if (has_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->v(), output);
  }

  // required double w = 2 [default = 0];
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->w(), output);
  }

  // optional double v2 = 3 [default = 0];
  if (has_v2()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->v2(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Velocity)
}

::google::protobuf::uint8* Velocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Velocity)
  // required double v = 1 [default = 0];
  if (has_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->v(), target);
  }

  // required double w = 2 [default = 0];
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->w(), target);
  }

  // optional double v2 = 3 [default = 0];
  if (has_v2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->v2(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Velocity)
  return target;
}

int Velocity::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_v()) {
    // required double v = 1 [default = 0];
    total_size += 1 + 8;
  }

  if (has_w()) {
    // required double w = 2 [default = 0];
    total_size += 1 + 8;
  }

  return total_size;
}
int Velocity::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double v = 1 [default = 0];
    total_size += 1 + 8;

    // required double w = 2 [default = 0];
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional double v2 = 3 [default = 0];
  if (has_v2()) {
    total_size += 1 + 8;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Velocity::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Velocity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Velocity>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Velocity::MergeFrom(const Velocity& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_v()) {
      set_v(from.v());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
    if (from.has_v2()) {
      set_v2(from.v2());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Velocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Velocity::CopyFrom(const Velocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Velocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Velocity::Swap(Velocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Velocity::InternalSwap(Velocity* other) {
  std::swap(v_, other->v_);
  std::swap(w_, other->w_);
  std::swap(v2_, other->v2_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Velocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Velocity_descriptor_;
  metadata.reflection = Velocity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Velocity

// required double v = 1 [default = 0];
bool Velocity::has_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Velocity::set_has_v() {
  _has_bits_[0] |= 0x00000001u;
}
void Velocity::clear_has_v() {
  _has_bits_[0] &= ~0x00000001u;
}
void Velocity::clear_v() {
  v_ = 0;
  clear_has_v();
}
 double Velocity::v() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.v)
  return v_;
}
 void Velocity::set_v(double value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.v)
}

// required double w = 2 [default = 0];
bool Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
void Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
void Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double Velocity::w() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.w)
  return w_;
}
 void Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.w)
}

// optional double v2 = 3 [default = 0];
bool Velocity::has_v2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Velocity::set_has_v2() {
  _has_bits_[0] |= 0x00000004u;
}
void Velocity::clear_has_v2() {
  _has_bits_[0] &= ~0x00000004u;
}
void Velocity::clear_v2() {
  v2_ = 0;
  clear_has_v2();
}
 double Velocity::v2() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.v2)
  return v2_;
}
 void Velocity::set_v2(double value) {
  set_has_v2();
  v2_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.v2)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose_Velocity::kXFieldNumber;
const int Pose_Velocity::kYFieldNumber;
const int Pose_Velocity::kYawFieldNumber;
const int Pose_Velocity::kVxFieldNumber;
const int Pose_Velocity::kVyFieldNumber;
const int Pose_Velocity::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose_Velocity::Pose_Velocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Pose_Velocity)
}

void Pose_Velocity::InitAsDefaultInstance() {
}

Pose_Velocity::Pose_Velocity(const Pose_Velocity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Pose_Velocity)
}

void Pose_Velocity::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  yaw_ = 0;
  vx_ = 0;
  vy_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pose_Velocity::~Pose_Velocity() {
  // @@protoc_insertion_point(destructor:stdmsg.Pose_Velocity)
  SharedDtor();
}

void Pose_Velocity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Pose_Velocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose_Velocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pose_Velocity_descriptor_;
}

const Pose_Velocity& Pose_Velocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Pose_Velocity* Pose_Velocity::default_instance_ = NULL;

Pose_Velocity* Pose_Velocity::New(::google::protobuf::Arena* arena) const {
  Pose_Velocity* n = new Pose_Velocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose_Velocity::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Pose_Velocity*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(x_, w_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Pose_Velocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Pose_Velocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_yaw;
        break;
      }

      // optional double yaw = 3 [default = 0];
      case 3: {
        if (tag == 25) {
         parse_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_vx;
        break;
      }

      // required double vx = 4 [default = 0];
      case 4: {
        if (tag == 33) {
         parse_vx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vx_)));
          set_has_vx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_vy;
        break;
      }

      // required double vy = 5 [default = 0];
      case 5: {
        if (tag == 41) {
         parse_vy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vy_)));
          set_has_vy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_w;
        break;
      }

      // required double w = 6 [default = 0];
      case 6: {
        if (tag == 49) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Pose_Velocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Pose_Velocity)
  return false;
#undef DO_
}

void Pose_Velocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Pose_Velocity)
  // optional double x = 1 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2 [default = 0];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double yaw = 3 [default = 0];
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->yaw(), output);
  }

  // required double vx = 4 [default = 0];
  if (has_vx()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->vx(), output);
  }

  // required double vy = 5 [default = 0];
  if (has_vy()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->vy(), output);
  }

  // required double w = 6 [default = 0];
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Pose_Velocity)
}

::google::protobuf::uint8* Pose_Velocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Pose_Velocity)
  // optional double x = 1 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2 [default = 0];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double yaw = 3 [default = 0];
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->yaw(), target);
  }

  // required double vx = 4 [default = 0];
  if (has_vx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->vx(), target);
  }

  // required double vy = 5 [default = 0];
  if (has_vy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->vy(), target);
  }

  // required double w = 6 [default = 0];
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Pose_Velocity)
  return target;
}

int Pose_Velocity::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_vx()) {
    // required double vx = 4 [default = 0];
    total_size += 1 + 8;
  }

  if (has_vy()) {
    // required double vy = 5 [default = 0];
    total_size += 1 + 8;
  }

  if (has_w()) {
    // required double w = 6 [default = 0];
    total_size += 1 + 8;
  }

  return total_size;
}
int Pose_Velocity::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000038) ^ 0x00000038) == 0) {  // All required fields are present.
    // required double vx = 4 [default = 0];
    total_size += 1 + 8;

    // required double vy = 5 [default = 0];
    total_size += 1 + 8;

    // required double w = 6 [default = 0];
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double x = 1 [default = 0];
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2 [default = 0];
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double yaw = 3 [default = 0];
    if (has_yaw()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose_Velocity::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Pose_Velocity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose_Velocity>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Pose_Velocity::MergeFrom(const Pose_Velocity& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
    if (from.has_vx()) {
      set_vx(from.vx());
    }
    if (from.has_vy()) {
      set_vy(from.vy());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Pose_Velocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose_Velocity::CopyFrom(const Pose_Velocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose_Velocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000038) != 0x00000038) return false;

  return true;
}

void Pose_Velocity::Swap(Pose_Velocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose_Velocity::InternalSwap(Pose_Velocity* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(yaw_, other->yaw_);
  std::swap(vx_, other->vx_);
  std::swap(vy_, other->vy_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose_Velocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pose_Velocity_descriptor_;
  metadata.reflection = Pose_Velocity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose_Velocity

// optional double x = 1 [default = 0];
bool Pose_Velocity::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Pose_Velocity::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Pose_Velocity::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Pose_Velocity::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Pose_Velocity::x() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.x)
  return x_;
}
 void Pose_Velocity::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.x)
}

// optional double y = 2 [default = 0];
bool Pose_Velocity::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Pose_Velocity::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Pose_Velocity::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Pose_Velocity::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Pose_Velocity::y() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.y)
  return y_;
}
 void Pose_Velocity::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.y)
}

// optional double yaw = 3 [default = 0];
bool Pose_Velocity::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Pose_Velocity::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
void Pose_Velocity::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
void Pose_Velocity::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
 double Pose_Velocity::yaw() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.yaw)
  return yaw_;
}
 void Pose_Velocity::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.yaw)
}

// required double vx = 4 [default = 0];
bool Pose_Velocity::has_vx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Pose_Velocity::set_has_vx() {
  _has_bits_[0] |= 0x00000008u;
}
void Pose_Velocity::clear_has_vx() {
  _has_bits_[0] &= ~0x00000008u;
}
void Pose_Velocity::clear_vx() {
  vx_ = 0;
  clear_has_vx();
}
 double Pose_Velocity::vx() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.vx)
  return vx_;
}
 void Pose_Velocity::set_vx(double value) {
  set_has_vx();
  vx_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.vx)
}

// required double vy = 5 [default = 0];
bool Pose_Velocity::has_vy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Pose_Velocity::set_has_vy() {
  _has_bits_[0] |= 0x00000010u;
}
void Pose_Velocity::clear_has_vy() {
  _has_bits_[0] &= ~0x00000010u;
}
void Pose_Velocity::clear_vy() {
  vy_ = 0;
  clear_has_vy();
}
 double Pose_Velocity::vy() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.vy)
  return vy_;
}
 void Pose_Velocity::set_vy(double value) {
  set_has_vy();
  vy_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.vy)
}

// required double w = 6 [default = 0];
bool Pose_Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Pose_Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
void Pose_Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
void Pose_Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double Pose_Velocity::w() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose_Velocity.w)
  return w_;
}
 void Pose_Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Pose_Velocity.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Laser_Scan_Laser_Config::kAngleMinFieldNumber;
const int Laser_Scan_Laser_Config::kAngleMaxFieldNumber;
const int Laser_Scan_Laser_Config::kAngleIncrementFieldNumber;
const int Laser_Scan_Laser_Config::kRangeMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Laser_Scan_Laser_Config::Laser_Scan_Laser_Config()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Laser_Scan.Laser_Config)
}

void Laser_Scan_Laser_Config::InitAsDefaultInstance() {
}

Laser_Scan_Laser_Config::Laser_Scan_Laser_Config(const Laser_Scan_Laser_Config& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Laser_Scan.Laser_Config)
}

void Laser_Scan_Laser_Config::SharedCtor() {
  _cached_size_ = 0;
  angle_min_ = 0;
  angle_max_ = 0;
  angle_increment_ = 0;
  range_max_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Laser_Scan_Laser_Config::~Laser_Scan_Laser_Config() {
  // @@protoc_insertion_point(destructor:stdmsg.Laser_Scan.Laser_Config)
  SharedDtor();
}

void Laser_Scan_Laser_Config::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Laser_Scan_Laser_Config::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Laser_Scan_Laser_Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Laser_Scan_Laser_Config_descriptor_;
}

const Laser_Scan_Laser_Config& Laser_Scan_Laser_Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Laser_Scan_Laser_Config* Laser_Scan_Laser_Config::default_instance_ = NULL;

Laser_Scan_Laser_Config* Laser_Scan_Laser_Config::New(::google::protobuf::Arena* arena) const {
  Laser_Scan_Laser_Config* n = new Laser_Scan_Laser_Config;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Laser_Scan_Laser_Config::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Laser_Scan_Laser_Config*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(angle_min_, range_max_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Laser_Scan_Laser_Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Laser_Scan.Laser_Config)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float angle_min = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_min_)));
          set_has_angle_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_angle_max;
        break;
      }

      // required float angle_max = 2;
      case 2: {
        if (tag == 21) {
         parse_angle_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_max_)));
          set_has_angle_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_angle_increment;
        break;
      }

      // required float angle_increment = 3;
      case 3: {
        if (tag == 29) {
         parse_angle_increment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_increment_)));
          set_has_angle_increment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_range_max;
        break;
      }

      // required float range_max = 5;
      case 5: {
        if (tag == 45) {
         parse_range_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &range_max_)));
          set_has_range_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Laser_Scan.Laser_Config)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Laser_Scan.Laser_Config)
  return false;
#undef DO_
}

void Laser_Scan_Laser_Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Laser_Scan.Laser_Config)
  // required float angle_min = 1;
  if (has_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->angle_min(), output);
  }

  // required float angle_max = 2;
  if (has_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->angle_max(), output);
  }

  // required float angle_increment = 3;
  if (has_angle_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle_increment(), output);
  }

  // required float range_max = 5;
  if (has_range_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->range_max(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Laser_Scan.Laser_Config)
}

::google::protobuf::uint8* Laser_Scan_Laser_Config::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Laser_Scan.Laser_Config)
  // required float angle_min = 1;
  if (has_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->angle_min(), target);
  }

  // required float angle_max = 2;
  if (has_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->angle_max(), target);
  }

  // required float angle_increment = 3;
  if (has_angle_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle_increment(), target);
  }

  // required float range_max = 5;
  if (has_range_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->range_max(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Laser_Scan.Laser_Config)
  return target;
}

int Laser_Scan_Laser_Config::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_angle_min()) {
    // required float angle_min = 1;
    total_size += 1 + 4;
  }

  if (has_angle_max()) {
    // required float angle_max = 2;
    total_size += 1 + 4;
  }

  if (has_angle_increment()) {
    // required float angle_increment = 3;
    total_size += 1 + 4;
  }

  if (has_range_max()) {
    // required float range_max = 5;
    total_size += 1 + 4;
  }

  return total_size;
}
int Laser_Scan_Laser_Config::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float angle_min = 1;
    total_size += 1 + 4;

    // required float angle_max = 2;
    total_size += 1 + 4;

    // required float angle_increment = 3;
    total_size += 1 + 4;

    // required float range_max = 5;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Laser_Scan_Laser_Config::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Laser_Scan_Laser_Config* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Laser_Scan_Laser_Config>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Laser_Scan_Laser_Config::MergeFrom(const Laser_Scan_Laser_Config& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_angle_min()) {
      set_angle_min(from.angle_min());
    }
    if (from.has_angle_max()) {
      set_angle_max(from.angle_max());
    }
    if (from.has_angle_increment()) {
      set_angle_increment(from.angle_increment());
    }
    if (from.has_range_max()) {
      set_range_max(from.range_max());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Laser_Scan_Laser_Config::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Laser_Scan_Laser_Config::CopyFrom(const Laser_Scan_Laser_Config& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Laser_Scan_Laser_Config::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Laser_Scan_Laser_Config::Swap(Laser_Scan_Laser_Config* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Laser_Scan_Laser_Config::InternalSwap(Laser_Scan_Laser_Config* other) {
  std::swap(angle_min_, other->angle_min_);
  std::swap(angle_max_, other->angle_max_);
  std::swap(angle_increment_, other->angle_increment_);
  std::swap(range_max_, other->range_max_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Laser_Scan_Laser_Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Laser_Scan_Laser_Config_descriptor_;
  metadata.reflection = Laser_Scan_Laser_Config_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Laser_Scan::kConfigFieldNumber;
const int Laser_Scan::kRangesFieldNumber;
const int Laser_Scan::kIntensitiesFieldNumber;
const int Laser_Scan::kPoseFieldNumber;
const int Laser_Scan::kRobotFieldNumber;
const int Laser_Scan::kSteerFieldNumber;
const int Laser_Scan::kSeqFieldNumber;
const int Laser_Scan::kAnnotationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Laser_Scan::Laser_Scan()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Laser_Scan)
}

void Laser_Scan::InitAsDefaultInstance() {
  config_ = const_cast< ::stdmsg::Laser_Scan_Laser_Config*>(&::stdmsg::Laser_Scan_Laser_Config::default_instance());
  pose_ = const_cast< ::stdmsg::Pose*>(&::stdmsg::Pose::default_instance());
  robot_ = const_cast< ::stdmsg::Pose*>(&::stdmsg::Pose::default_instance());
}

Laser_Scan::Laser_Scan(const Laser_Scan& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Laser_Scan)
}

void Laser_Scan::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  config_ = NULL;
  pose_ = NULL;
  robot_ = NULL;
  steer_ = 0;
  seq_ = 0;
  annotation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Laser_Scan::~Laser_Scan() {
  // @@protoc_insertion_point(destructor:stdmsg.Laser_Scan)
  SharedDtor();
}

void Laser_Scan::SharedDtor() {
  annotation_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete config_;
    delete pose_;
    delete robot_;
  }
}

void Laser_Scan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Laser_Scan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Laser_Scan_descriptor_;
}

const Laser_Scan& Laser_Scan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Laser_Scan* Laser_Scan::default_instance_ = NULL;

Laser_Scan* Laser_Scan::New(::google::protobuf::Arena* arena) const {
  Laser_Scan* n = new Laser_Scan;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Laser_Scan::Clear() {
  if (_has_bits_[0 / 32] & 249u) {
    if (has_config()) {
      if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
    }
    if (has_pose()) {
      if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
    }
    if (has_robot()) {
      if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
    }
    steer_ = 0;
    seq_ = 0;
    if (has_annotation()) {
      annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ranges_.Clear();
  intensities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Laser_Scan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Laser_Scan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .stdmsg.Laser_Scan.Laser_Config config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_ranges;
        break;
      }

      // repeated float ranges = 2;
      case 2: {
        if (tag == 21) {
         parse_ranges:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_ranges())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_ranges())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_ranges;
        if (input->ExpectTag(29)) goto parse_intensities;
        break;
      }

      // repeated float intensities = 3;
      case 3: {
        if (tag == 29) {
         parse_intensities:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_intensities())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_intensities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_intensities;
        if (input->ExpectTag(42)) goto parse_pose;
        break;
      }

      // required .stdmsg.Pose pose = 5;
      case 5: {
        if (tag == 42) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_robot;
        break;
      }

      // required .stdmsg.Pose robot = 6;
      case 6: {
        if (tag == 50) {
         parse_robot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_seq;
        break;
      }

      // optional int32 seq = 7 [default = 0];
      case 7: {
        if (tag == 56) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_annotation;
        break;
      }

      // optional string annotation = 8 [default = ""];
      case 8: {
        if (tag == 66) {
         parse_annotation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_annotation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->annotation().data(), this->annotation().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Laser_Scan.annotation");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_steer;
        break;
      }

      // optional double steer = 9;
      case 9: {
        if (tag == 73) {
         parse_steer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_)));
          set_has_steer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Laser_Scan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Laser_Scan)
  return false;
#undef DO_
}

void Laser_Scan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Laser_Scan)
  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->config_, output);
  }

  // repeated float ranges = 2;
  for (int i = 0; i < this->ranges_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->ranges(i), output);
  }

  // repeated float intensities = 3;
  for (int i = 0; i < this->intensities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->intensities(i), output);
  }

  // required .stdmsg.Pose pose = 5;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->pose_, output);
  }

  // required .stdmsg.Pose robot = 6;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->robot_, output);
  }

  // optional int32 seq = 7 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->seq(), output);
  }

  // optional string annotation = 8 [default = ""];
  if (has_annotation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->annotation().data(), this->annotation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Laser_Scan.annotation");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->annotation(), output);
  }

  // optional double steer = 9;
  if (has_steer()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->steer(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Laser_Scan)
}

::google::protobuf::uint8* Laser_Scan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Laser_Scan)
  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  if (has_config()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->config_, target);
  }

  // repeated float ranges = 2;
  for (int i = 0; i < this->ranges_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->ranges(i), target);
  }

  // repeated float intensities = 3;
  for (int i = 0; i < this->intensities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(3, this->intensities(i), target);
  }

  // required .stdmsg.Pose pose = 5;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->pose_, target);
  }

  // required .stdmsg.Pose robot = 6;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->robot_, target);
  }

  // optional int32 seq = 7 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->seq(), target);
  }

  // optional string annotation = 8 [default = ""];
  if (has_annotation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->annotation().data(), this->annotation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Laser_Scan.annotation");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->annotation(), target);
  }

  // optional double steer = 9;
  if (has_steer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->steer(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Laser_Scan)
  return target;
}

int Laser_Scan::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_config()) {
    // required .stdmsg.Laser_Scan.Laser_Config config = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->config_);
  }

  if (has_pose()) {
    // required .stdmsg.Pose pose = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  if (has_robot()) {
    // required .stdmsg.Pose robot = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->robot_);
  }

  return total_size;
}
int Laser_Scan::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required .stdmsg.Laser_Scan.Laser_Config config = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->config_);

    // required .stdmsg.Pose pose = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);

    // required .stdmsg.Pose robot = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->robot_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[5 / 32] & 224u) {
    // optional double steer = 9;
    if (has_steer()) {
      total_size += 1 + 8;
    }

    // optional int32 seq = 7 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // optional string annotation = 8 [default = ""];
    if (has_annotation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->annotation());
    }

  }
  // repeated float ranges = 2;
  {
    int data_size = 0;
    data_size = 4 * this->ranges_size();
    total_size += 1 * this->ranges_size() + data_size;
  }

  // repeated float intensities = 3;
  {
    int data_size = 0;
    data_size = 4 * this->intensities_size();
    total_size += 1 * this->intensities_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Laser_Scan::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Laser_Scan* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Laser_Scan>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Laser_Scan::MergeFrom(const Laser_Scan& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  ranges_.MergeFrom(from.ranges_);
  intensities_.MergeFrom(from.intensities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_config()) {
      mutable_config()->::stdmsg::Laser_Scan_Laser_Config::MergeFrom(from.config());
    }
    if (from.has_pose()) {
      mutable_pose()->::stdmsg::Pose::MergeFrom(from.pose());
    }
    if (from.has_robot()) {
      mutable_robot()->::stdmsg::Pose::MergeFrom(from.robot());
    }
    if (from.has_steer()) {
      set_steer(from.steer());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_annotation()) {
      set_has_annotation();
      annotation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.annotation_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Laser_Scan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Laser_Scan::CopyFrom(const Laser_Scan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Laser_Scan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;

  if (has_config()) {
    if (!this->config_->IsInitialized()) return false;
  }
  if (has_pose()) {
    if (!this->pose_->IsInitialized()) return false;
  }
  if (has_robot()) {
    if (!this->robot_->IsInitialized()) return false;
  }
  return true;
}

void Laser_Scan::Swap(Laser_Scan* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Laser_Scan::InternalSwap(Laser_Scan* other) {
  std::swap(config_, other->config_);
  ranges_.UnsafeArenaSwap(&other->ranges_);
  intensities_.UnsafeArenaSwap(&other->intensities_);
  std::swap(pose_, other->pose_);
  std::swap(robot_, other->robot_);
  std::swap(steer_, other->steer_);
  std::swap(seq_, other->seq_);
  annotation_.Swap(&other->annotation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Laser_Scan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Laser_Scan_descriptor_;
  metadata.reflection = Laser_Scan_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Laser_Scan_Laser_Config

// required float angle_min = 1;
bool Laser_Scan_Laser_Config::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Laser_Scan_Laser_Config::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
void Laser_Scan_Laser_Config::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
void Laser_Scan_Laser_Config::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
 float Laser_Scan_Laser_Config::angle_min() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_min)
  return angle_min_;
}
 void Laser_Scan_Laser_Config::set_angle_min(float value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_min)
}

// required float angle_max = 2;
bool Laser_Scan_Laser_Config::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Laser_Scan_Laser_Config::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
void Laser_Scan_Laser_Config::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
void Laser_Scan_Laser_Config::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
 float Laser_Scan_Laser_Config::angle_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_max)
  return angle_max_;
}
 void Laser_Scan_Laser_Config::set_angle_max(float value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_max)
}

// required float angle_increment = 3;
bool Laser_Scan_Laser_Config::has_angle_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Laser_Scan_Laser_Config::set_has_angle_increment() {
  _has_bits_[0] |= 0x00000004u;
}
void Laser_Scan_Laser_Config::clear_has_angle_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
void Laser_Scan_Laser_Config::clear_angle_increment() {
  angle_increment_ = 0;
  clear_has_angle_increment();
}
 float Laser_Scan_Laser_Config::angle_increment() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_increment)
  return angle_increment_;
}
 void Laser_Scan_Laser_Config::set_angle_increment(float value) {
  set_has_angle_increment();
  angle_increment_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_increment)
}

// required float range_max = 5;
bool Laser_Scan_Laser_Config::has_range_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Laser_Scan_Laser_Config::set_has_range_max() {
  _has_bits_[0] |= 0x00000008u;
}
void Laser_Scan_Laser_Config::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000008u;
}
void Laser_Scan_Laser_Config::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
 float Laser_Scan_Laser_Config::range_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.range_max)
  return range_max_;
}
 void Laser_Scan_Laser_Config::set_range_max(float value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.range_max)
}

// -------------------------------------------------------------------

// Laser_Scan

// required .stdmsg.Laser_Scan.Laser_Config config = 1;
bool Laser_Scan::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Laser_Scan::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
void Laser_Scan::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void Laser_Scan::clear_config() {
  if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
  clear_has_config();
}
const ::stdmsg::Laser_Scan_Laser_Config& Laser_Scan::config() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::stdmsg::Laser_Scan_Laser_Config;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.config)
  return config_;
}
::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::release_config() {
  clear_has_config();
  ::stdmsg::Laser_Scan_Laser_Config* temp = config_;
  config_ = NULL;
  return temp;
}
void Laser_Scan::set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.config)
}

// repeated float ranges = 2;
int Laser_Scan::ranges_size() const {
  return ranges_.size();
}
void Laser_Scan::clear_ranges() {
  ranges_.Clear();
}
 float Laser_Scan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.ranges)
  return ranges_.Get(index);
}
 void Laser_Scan::set_ranges(int index, float value) {
  ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.ranges)
}
 void Laser_Scan::add_ranges(float value) {
  ranges_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.ranges)
}
 const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.ranges)
  return ranges_;
}
 ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.ranges)
  return &ranges_;
}

// repeated float intensities = 3;
int Laser_Scan::intensities_size() const {
  return intensities_.size();
}
void Laser_Scan::clear_intensities() {
  intensities_.Clear();
}
 float Laser_Scan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.intensities)
  return intensities_.Get(index);
}
 void Laser_Scan::set_intensities(int index, float value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.intensities)
}
 void Laser_Scan::add_intensities(float value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.intensities)
}
 const ::google::protobuf::RepeatedField< float >&
Laser_Scan::intensities() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.intensities)
  return intensities_;
}
 ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.intensities)
  return &intensities_;
}

// required .stdmsg.Pose pose = 5;
bool Laser_Scan::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Laser_Scan::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
void Laser_Scan::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
void Laser_Scan::clear_pose() {
  if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
  clear_has_pose();
}
const ::stdmsg::Pose& Laser_Scan::pose() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
::stdmsg::Pose* Laser_Scan::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.pose)
  return pose_;
}
::stdmsg::Pose* Laser_Scan::release_pose() {
  clear_has_pose();
  ::stdmsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void Laser_Scan::set_allocated_pose(::stdmsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.pose)
}

// required .stdmsg.Pose robot = 6;
bool Laser_Scan::has_robot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Laser_Scan::set_has_robot() {
  _has_bits_[0] |= 0x00000010u;
}
void Laser_Scan::clear_has_robot() {
  _has_bits_[0] &= ~0x00000010u;
}
void Laser_Scan::clear_robot() {
  if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
  clear_has_robot();
}
const ::stdmsg::Pose& Laser_Scan::robot() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
::stdmsg::Pose* Laser_Scan::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    robot_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.robot)
  return robot_;
}
::stdmsg::Pose* Laser_Scan::release_robot() {
  clear_has_robot();
  ::stdmsg::Pose* temp = robot_;
  robot_ = NULL;
  return temp;
}
void Laser_Scan::set_allocated_robot(::stdmsg::Pose* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.robot)
}

// optional double steer = 9;
bool Laser_Scan::has_steer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Laser_Scan::set_has_steer() {
  _has_bits_[0] |= 0x00000020u;
}
void Laser_Scan::clear_has_steer() {
  _has_bits_[0] &= ~0x00000020u;
}
void Laser_Scan::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
 double Laser_Scan::steer() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.steer)
  return steer_;
}
 void Laser_Scan::set_steer(double value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.steer)
}

// optional int32 seq = 7 [default = 0];
bool Laser_Scan::has_seq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Laser_Scan::set_has_seq() {
  _has_bits_[0] |= 0x00000040u;
}
void Laser_Scan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000040u;
}
void Laser_Scan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 Laser_Scan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.seq)
  return seq_;
}
 void Laser_Scan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.seq)
}

// optional string annotation = 8 [default = ""];
bool Laser_Scan::has_annotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Laser_Scan::set_has_annotation() {
  _has_bits_[0] |= 0x00000080u;
}
void Laser_Scan::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000080u;
}
void Laser_Scan::clear_annotation() {
  annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_annotation();
}
 const ::std::string& Laser_Scan::annotation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.annotation)
  return annotation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Laser_Scan::set_annotation(const ::std::string& value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.annotation)
}
 void Laser_Scan::set_annotation(const char* value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Laser_Scan.annotation)
}
 void Laser_Scan::set_annotation(const char* value, size_t size) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Laser_Scan.annotation)
}
 ::std::string* Laser_Scan::mutable_annotation() {
  set_has_annotation();
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.annotation)
  return annotation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Laser_Scan::release_annotation() {
  clear_has_annotation();
  return annotation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Laser_Scan::set_allocated_annotation(::std::string* annotation) {
  if (annotation != NULL) {
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
  annotation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotation);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.annotation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Global_Plan::kPathFieldNumber;
const int Global_Plan::kSeqFieldNumber;
const int Global_Plan::kGoalReachedFieldNumber;
const int Global_Plan::kDistanceGoalReachedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Global_Plan::Global_Plan()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Global_Plan)
}

void Global_Plan::InitAsDefaultInstance() {
}

Global_Plan::Global_Plan(const Global_Plan& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Global_Plan)
}

void Global_Plan::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  goal_reached_ = 0;
  distance_goal_reached_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Global_Plan::~Global_Plan() {
  // @@protoc_insertion_point(destructor:stdmsg.Global_Plan)
  SharedDtor();
}

void Global_Plan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Global_Plan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Global_Plan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Global_Plan_descriptor_;
}

const Global_Plan& Global_Plan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Global_Plan* Global_Plan::default_instance_ = NULL;

Global_Plan* Global_Plan::New(::google::protobuf::Arena* arena) const {
  Global_Plan* n = new Global_Plan;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Global_Plan::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Global_Plan*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(seq_, distance_goal_reached_);

#undef ZR_HELPER_
#undef ZR_

  path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Global_Plan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Global_Plan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .stdmsg.Pose path = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_path;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_goal_reached;
        break;
      }

      // optional int32 goal_reached = 3 [default = 0];
      case 3: {
        if (tag == 24) {
         parse_goal_reached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &goal_reached_)));
          set_has_goal_reached();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_distance_goal_reached;
        break;
      }

      // optional int32 distance_goal_reached = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_distance_goal_reached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &distance_goal_reached_)));
          set_has_distance_goal_reached();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Global_Plan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Global_Plan)
  return false;
#undef DO_
}

void Global_Plan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Global_Plan)
  // repeated .stdmsg.Pose path = 1;
  for (unsigned int i = 0, n = this->path_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->path(i), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  // optional int32 goal_reached = 3 [default = 0];
  if (has_goal_reached()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->goal_reached(), output);
  }

  // optional int32 distance_goal_reached = 4 [default = 0];
  if (has_distance_goal_reached()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->distance_goal_reached(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Global_Plan)
}

::google::protobuf::uint8* Global_Plan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Global_Plan)
  // repeated .stdmsg.Pose path = 1;
  for (unsigned int i = 0, n = this->path_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->path(i), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  // optional int32 goal_reached = 3 [default = 0];
  if (has_goal_reached()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->goal_reached(), target);
  }

  // optional int32 distance_goal_reached = 4 [default = 0];
  if (has_distance_goal_reached()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->distance_goal_reached(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Global_Plan)
  return target;
}

int Global_Plan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & 14u) {
    // optional int32 seq = 2 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // optional int32 goal_reached = 3 [default = 0];
    if (has_goal_reached()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->goal_reached());
    }

    // optional int32 distance_goal_reached = 4 [default = 0];
    if (has_distance_goal_reached()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->distance_goal_reached());
    }

  }
  // repeated .stdmsg.Pose path = 1;
  total_size += 1 * this->path_size();
  for (int i = 0; i < this->path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->path(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Global_Plan::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Global_Plan* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Global_Plan>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Global_Plan::MergeFrom(const Global_Plan& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  path_.MergeFrom(from.path_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_goal_reached()) {
      set_goal_reached(from.goal_reached());
    }
    if (from.has_distance_goal_reached()) {
      set_distance_goal_reached(from.distance_goal_reached());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Global_Plan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Global_Plan::CopyFrom(const Global_Plan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Global_Plan::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->path())) return false;
  return true;
}

void Global_Plan::Swap(Global_Plan* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Global_Plan::InternalSwap(Global_Plan* other) {
  path_.UnsafeArenaSwap(&other->path_);
  std::swap(seq_, other->seq_);
  std::swap(goal_reached_, other->goal_reached_);
  std::swap(distance_goal_reached_, other->distance_goal_reached_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Global_Plan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Global_Plan_descriptor_;
  metadata.reflection = Global_Plan_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Global_Plan

// repeated .stdmsg.Pose path = 1;
int Global_Plan::path_size() const {
  return path_.size();
}
void Global_Plan::clear_path() {
  path_.Clear();
}
const ::stdmsg::Pose& Global_Plan::path(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.path)
  return path_.Get(index);
}
::stdmsg::Pose* Global_Plan::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Global_Plan.path)
  return path_.Mutable(index);
}
::stdmsg::Pose* Global_Plan::add_path() {
  // @@protoc_insertion_point(field_add:stdmsg.Global_Plan.path)
  return path_.Add();
}
::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
Global_Plan::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Global_Plan.path)
  return &path_;
}
const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
Global_Plan::path() const {
  // @@protoc_insertion_point(field_list:stdmsg.Global_Plan.path)
  return path_;
}

// optional int32 seq = 2 [default = 0];
bool Global_Plan::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Global_Plan::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void Global_Plan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void Global_Plan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 Global_Plan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.seq)
  return seq_;
}
 void Global_Plan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.seq)
}

// optional int32 goal_reached = 3 [default = 0];
bool Global_Plan::has_goal_reached() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Global_Plan::set_has_goal_reached() {
  _has_bits_[0] |= 0x00000004u;
}
void Global_Plan::clear_has_goal_reached() {
  _has_bits_[0] &= ~0x00000004u;
}
void Global_Plan::clear_goal_reached() {
  goal_reached_ = 0;
  clear_has_goal_reached();
}
 ::google::protobuf::int32 Global_Plan::goal_reached() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.goal_reached)
  return goal_reached_;
}
 void Global_Plan::set_goal_reached(::google::protobuf::int32 value) {
  set_has_goal_reached();
  goal_reached_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.goal_reached)
}

// optional int32 distance_goal_reached = 4 [default = 0];
bool Global_Plan::has_distance_goal_reached() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Global_Plan::set_has_distance_goal_reached() {
  _has_bits_[0] |= 0x00000008u;
}
void Global_Plan::clear_has_distance_goal_reached() {
  _has_bits_[0] &= ~0x00000008u;
}
void Global_Plan::clear_distance_goal_reached() {
  distance_goal_reached_ = 0;
  clear_has_distance_goal_reached();
}
 ::google::protobuf::int32 Global_Plan::distance_goal_reached() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.distance_goal_reached)
  return distance_goal_reached_;
}
 void Global_Plan::set_distance_goal_reached(::google::protobuf::int32 value) {
  set_has_distance_goal_reached();
  distance_goal_reached_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.distance_goal_reached)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Data::kDataFieldNumber;
const int Data::kSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Data::Data()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Data)
}

void Data::InitAsDefaultInstance() {
}

Data::Data(const Data& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Data)
}

void Data::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Data::~Data() {
  // @@protoc_insertion_point(destructor:stdmsg.Data)
  SharedDtor();
}

void Data::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Data_descriptor_;
}

const Data& Data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Data* Data::default_instance_ = NULL;

Data* Data::New(::google::protobuf::Arena* arena) const {
  Data* n = new Data;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Data::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Data)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1 [default = ""];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Data)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Data)
  return false;
#undef DO_
}

void Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Data)
  // optional bytes data = 1 [default = ""];
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Data)
}

::google::protobuf::uint8* Data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Data)
  // optional bytes data = 1 [default = ""];
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data(), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Data)
  return target;
}

int Data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes data = 1 [default = ""];
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional int32 seq = 2 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Data::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Data* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Data>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Data::MergeFrom(const Data& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Data::CopyFrom(const Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Data::IsInitialized() const {

  return true;
}

void Data::Swap(Data* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Data::InternalSwap(Data* other) {
  data_.Swap(&other->data_);
  std::swap(seq_, other->seq_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Data_descriptor_;
  metadata.reflection = Data_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Data

// optional bytes data = 1 [default = ""];
bool Data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void Data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Data::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Data.data)
}
 void Data::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Data.data)
}
 void Data::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Data.data)
}
 ::std::string* Data::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:stdmsg.Data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Data::release_data() {
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Data.data)
}

// optional int32 seq = 2 [default = 0];
bool Data::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Data::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void Data::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void Data::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 Data::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.seq)
  return seq_;
}
 void Data::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Data.seq)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int String::kStrFieldNumber;
const int String::kSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

String::String()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.String)
}

void String::InitAsDefaultInstance() {
}

String::String(const String& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.String)
}

void String::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

String::~String() {
  // @@protoc_insertion_point(destructor:stdmsg.String)
  SharedDtor();
}

void String::SharedDtor() {
  str_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void String::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* String::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return String_descriptor_;
}

const String& String::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

String* String::default_instance_ = NULL;

String* String::New(::google::protobuf::Arena* arena) const {
  String* n = new String;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void String::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_str()) {
      str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool String::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.String)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string str = 1 [default = ""];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_str()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->str().data(), this->str().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.String.str");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.String)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.String)
  return false;
#undef DO_
}

void String::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.String)
  // optional string str = 1 [default = ""];
  if (has_str()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->str().data(), this->str().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.String.str");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->str(), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.String)
}

::google::protobuf::uint8* String::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.String)
  // optional string str = 1 [default = ""];
  if (has_str()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->str().data(), this->str().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.String.str");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->str(), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.String)
  return target;
}

int String::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string str = 1 [default = ""];
    if (has_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->str());
    }

    // optional int32 seq = 2 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void String::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const String* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const String>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void String::MergeFrom(const String& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_str()) {
      set_has_str();
      str_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.str_);
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void String::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void String::CopyFrom(const String& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool String::IsInitialized() const {

  return true;
}

void String::Swap(String* other) {
  if (other == this) return;
  InternalSwap(other);
}
void String::InternalSwap(String* other) {
  str_.Swap(&other->str_);
  std::swap(seq_, other->seq_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata String::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = String_descriptor_;
  metadata.reflection = String_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// String

// optional string str = 1 [default = ""];
bool String::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void String::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
void String::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
void String::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
 const ::std::string& String::str() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.str)
  return str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void String::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.String.str)
}
 void String::set_str(const char* value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.String.str)
}
 void String::set_str(const char* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.String.str)
}
 ::std::string* String::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:stdmsg.String.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* String::release_str() {
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void String::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.String.str)
}

// optional int32 seq = 2 [default = 0];
bool String::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void String::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void String::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void String::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 String::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.seq)
  return seq_;
}
 void String::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.String.seq)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserList::kScansFieldNumber;
const int LaserList::kSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserList::LaserList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.LaserList)
}

void LaserList::InitAsDefaultInstance() {
}

LaserList::LaserList(const LaserList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.LaserList)
}

void LaserList::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaserList::~LaserList() {
  // @@protoc_insertion_point(destructor:stdmsg.LaserList)
  SharedDtor();
}

void LaserList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaserList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaserList_descriptor_;
}

const LaserList& LaserList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

LaserList* LaserList::default_instance_ = NULL;

LaserList* LaserList::New(::google::protobuf::Arena* arena) const {
  LaserList* n = new LaserList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaserList::Clear() {
  seq_ = 0;
  scans_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaserList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.LaserList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .stdmsg.Laser_Scan scans = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_scans:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_scans()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_scans;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.LaserList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.LaserList)
  return false;
#undef DO_
}

void LaserList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.LaserList)
  // repeated .stdmsg.Laser_Scan scans = 1;
  for (unsigned int i = 0, n = this->scans_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->scans(i), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.LaserList)
}

::google::protobuf::uint8* LaserList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.LaserList)
  // repeated .stdmsg.Laser_Scan scans = 1;
  for (unsigned int i = 0, n = this->scans_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->scans(i), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.LaserList)
  return target;
}

int LaserList::ByteSize() const {
  int total_size = 0;

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->seq());
  }

  // repeated .stdmsg.Laser_Scan scans = 1;
  total_size += 1 * this->scans_size();
  for (int i = 0; i < this->scans_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->scans(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserList::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LaserList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaserList>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaserList::MergeFrom(const LaserList& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  scans_.MergeFrom(from.scans_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaserList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserList::CopyFrom(const LaserList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserList::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->scans())) return false;
  return true;
}

void LaserList::Swap(LaserList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserList::InternalSwap(LaserList* other) {
  scans_.UnsafeArenaSwap(&other->scans_);
  std::swap(seq_, other->seq_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaserList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaserList_descriptor_;
  metadata.reflection = LaserList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserList

// repeated .stdmsg.Laser_Scan scans = 1;
int LaserList::scans_size() const {
  return scans_.size();
}
void LaserList::clear_scans() {
  scans_.Clear();
}
const ::stdmsg::Laser_Scan& LaserList::scans(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.scans)
  return scans_.Get(index);
}
::stdmsg::Laser_Scan* LaserList::mutable_scans(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.LaserList.scans)
  return scans_.Mutable(index);
}
::stdmsg::Laser_Scan* LaserList::add_scans() {
  // @@protoc_insertion_point(field_add:stdmsg.LaserList.scans)
  return scans_.Add();
}
::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
LaserList::mutable_scans() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.LaserList.scans)
  return &scans_;
}
const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
LaserList::scans() const {
  // @@protoc_insertion_point(field_list:stdmsg.LaserList.scans)
  return scans_;
}

// optional int32 seq = 2 [default = 0];
bool LaserList::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaserList::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void LaserList::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaserList::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 LaserList::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.seq)
  return seq_;
}
 void LaserList::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.LaserList.seq)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MoveMode::kMoveModeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MoveMode::MoveMode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.MoveMode)
}

void MoveMode::InitAsDefaultInstance() {
}

MoveMode::MoveMode(const MoveMode& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.MoveMode)
}

void MoveMode::SharedCtor() {
  _cached_size_ = 0;
  move_mode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MoveMode::~MoveMode() {
  // @@protoc_insertion_point(destructor:stdmsg.MoveMode)
  SharedDtor();
}

void MoveMode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MoveMode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MoveMode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MoveMode_descriptor_;
}

const MoveMode& MoveMode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

MoveMode* MoveMode::default_instance_ = NULL;

MoveMode* MoveMode::New(::google::protobuf::Arena* arena) const {
  MoveMode* n = new MoveMode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MoveMode::Clear() {
  move_mode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MoveMode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.MoveMode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 move_mode = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_mode_)));
          set_has_move_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.MoveMode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.MoveMode)
  return false;
#undef DO_
}

void MoveMode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.MoveMode)
  // required int32 move_mode = 1 [default = 0];
  if (has_move_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->move_mode(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.MoveMode)
}

::google::protobuf::uint8* MoveMode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.MoveMode)
  // required int32 move_mode = 1 [default = 0];
  if (has_move_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->move_mode(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.MoveMode)
  return target;
}

int MoveMode::ByteSize() const {
  int total_size = 0;

  // required int32 move_mode = 1 [default = 0];
  if (has_move_mode()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->move_mode());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MoveMode::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MoveMode* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MoveMode>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MoveMode::MergeFrom(const MoveMode& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_move_mode()) {
      set_move_mode(from.move_mode());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MoveMode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MoveMode::CopyFrom(const MoveMode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveMode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MoveMode::Swap(MoveMode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MoveMode::InternalSwap(MoveMode* other) {
  std::swap(move_mode_, other->move_mode_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MoveMode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MoveMode_descriptor_;
  metadata.reflection = MoveMode_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MoveMode

// required int32 move_mode = 1 [default = 0];
bool MoveMode::has_move_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MoveMode::set_has_move_mode() {
  _has_bits_[0] |= 0x00000001u;
}
void MoveMode::clear_has_move_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
void MoveMode::clear_move_mode() {
  move_mode_ = 0;
  clear_has_move_mode();
}
 ::google::protobuf::int32 MoveMode::move_mode() const {
  // @@protoc_insertion_point(field_get:stdmsg.MoveMode.move_mode)
  return move_mode_;
}
 void MoveMode::set_move_mode(::google::protobuf::int32 value) {
  set_has_move_mode();
  move_mode_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.MoveMode.move_mode)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SomeFlag::kEmergencyStopFlagFieldNumber;
const int SomeFlag::kObstacleForwardFlagFieldNumber;
const int SomeFlag::kMoveModeFlagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SomeFlag::SomeFlag()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.SomeFlag)
}

void SomeFlag::InitAsDefaultInstance() {
}

SomeFlag::SomeFlag(const SomeFlag& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.SomeFlag)
}

void SomeFlag::SharedCtor() {
  _cached_size_ = 0;
  emergency_stop_flag_ = 0;
  obstacle_forward_flag_ = 0;
  move_mode_flag_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SomeFlag::~SomeFlag() {
  // @@protoc_insertion_point(destructor:stdmsg.SomeFlag)
  SharedDtor();
}

void SomeFlag::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SomeFlag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SomeFlag::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SomeFlag_descriptor_;
}

const SomeFlag& SomeFlag::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

SomeFlag* SomeFlag::default_instance_ = NULL;

SomeFlag* SomeFlag::New(::google::protobuf::Arena* arena) const {
  SomeFlag* n = new SomeFlag;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SomeFlag::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SomeFlag*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(emergency_stop_flag_, move_mode_flag_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SomeFlag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.SomeFlag)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 emergency_stop_flag = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &emergency_stop_flag_)));
          set_has_emergency_stop_flag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_obstacle_forward_flag;
        break;
      }

      // optional int32 obstacle_forward_flag = 2;
      case 2: {
        if (tag == 16) {
         parse_obstacle_forward_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &obstacle_forward_flag_)));
          set_has_obstacle_forward_flag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_move_mode_flag;
        break;
      }

      // optional int32 move_mode_flag = 3;
      case 3: {
        if (tag == 24) {
         parse_move_mode_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_mode_flag_)));
          set_has_move_mode_flag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.SomeFlag)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.SomeFlag)
  return false;
#undef DO_
}

void SomeFlag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.SomeFlag)
  // optional int32 emergency_stop_flag = 1;
  if (has_emergency_stop_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->emergency_stop_flag(), output);
  }

  // optional int32 obstacle_forward_flag = 2;
  if (has_obstacle_forward_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->obstacle_forward_flag(), output);
  }

  // optional int32 move_mode_flag = 3;
  if (has_move_mode_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->move_mode_flag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.SomeFlag)
}

::google::protobuf::uint8* SomeFlag::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.SomeFlag)
  // optional int32 emergency_stop_flag = 1;
  if (has_emergency_stop_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->emergency_stop_flag(), target);
  }

  // optional int32 obstacle_forward_flag = 2;
  if (has_obstacle_forward_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->obstacle_forward_flag(), target);
  }

  // optional int32 move_mode_flag = 3;
  if (has_move_mode_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->move_mode_flag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.SomeFlag)
  return target;
}

int SomeFlag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional int32 emergency_stop_flag = 1;
    if (has_emergency_stop_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->emergency_stop_flag());
    }

    // optional int32 obstacle_forward_flag = 2;
    if (has_obstacle_forward_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->obstacle_forward_flag());
    }

    // optional int32 move_mode_flag = 3;
    if (has_move_mode_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->move_mode_flag());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SomeFlag::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SomeFlag* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SomeFlag>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SomeFlag::MergeFrom(const SomeFlag& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_emergency_stop_flag()) {
      set_emergency_stop_flag(from.emergency_stop_flag());
    }
    if (from.has_obstacle_forward_flag()) {
      set_obstacle_forward_flag(from.obstacle_forward_flag());
    }
    if (from.has_move_mode_flag()) {
      set_move_mode_flag(from.move_mode_flag());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SomeFlag::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SomeFlag::CopyFrom(const SomeFlag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SomeFlag::IsInitialized() const {

  return true;
}

void SomeFlag::Swap(SomeFlag* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SomeFlag::InternalSwap(SomeFlag* other) {
  std::swap(emergency_stop_flag_, other->emergency_stop_flag_);
  std::swap(obstacle_forward_flag_, other->obstacle_forward_flag_);
  std::swap(move_mode_flag_, other->move_mode_flag_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SomeFlag::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SomeFlag_descriptor_;
  metadata.reflection = SomeFlag_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SomeFlag

// optional int32 emergency_stop_flag = 1;
bool SomeFlag::has_emergency_stop_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SomeFlag::set_has_emergency_stop_flag() {
  _has_bits_[0] |= 0x00000001u;
}
void SomeFlag::clear_has_emergency_stop_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
void SomeFlag::clear_emergency_stop_flag() {
  emergency_stop_flag_ = 0;
  clear_has_emergency_stop_flag();
}
 ::google::protobuf::int32 SomeFlag::emergency_stop_flag() const {
  // @@protoc_insertion_point(field_get:stdmsg.SomeFlag.emergency_stop_flag)
  return emergency_stop_flag_;
}
 void SomeFlag::set_emergency_stop_flag(::google::protobuf::int32 value) {
  set_has_emergency_stop_flag();
  emergency_stop_flag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.SomeFlag.emergency_stop_flag)
}

// optional int32 obstacle_forward_flag = 2;
bool SomeFlag::has_obstacle_forward_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SomeFlag::set_has_obstacle_forward_flag() {
  _has_bits_[0] |= 0x00000002u;
}
void SomeFlag::clear_has_obstacle_forward_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
void SomeFlag::clear_obstacle_forward_flag() {
  obstacle_forward_flag_ = 0;
  clear_has_obstacle_forward_flag();
}
 ::google::protobuf::int32 SomeFlag::obstacle_forward_flag() const {
  // @@protoc_insertion_point(field_get:stdmsg.SomeFlag.obstacle_forward_flag)
  return obstacle_forward_flag_;
}
 void SomeFlag::set_obstacle_forward_flag(::google::protobuf::int32 value) {
  set_has_obstacle_forward_flag();
  obstacle_forward_flag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.SomeFlag.obstacle_forward_flag)
}

// optional int32 move_mode_flag = 3;
bool SomeFlag::has_move_mode_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SomeFlag::set_has_move_mode_flag() {
  _has_bits_[0] |= 0x00000004u;
}
void SomeFlag::clear_has_move_mode_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
void SomeFlag::clear_move_mode_flag() {
  move_mode_flag_ = 0;
  clear_has_move_mode_flag();
}
 ::google::protobuf::int32 SomeFlag::move_mode_flag() const {
  // @@protoc_insertion_point(field_get:stdmsg.SomeFlag.move_mode_flag)
  return move_mode_flag_;
}
 void SomeFlag::set_move_mode_flag(::google::protobuf::int32 value) {
  set_has_move_mode_flag();
  move_mode_flag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.SomeFlag.move_mode_flag)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NavConfig::kStopDeltaDistanceFieldNumber;
const int NavConfig::kStopDeltaThetaFieldNumber;
const int NavConfig::kNavVFieldNumber;
const int NavConfig::kNavWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NavConfig::NavConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.NavConfig)
}

void NavConfig::InitAsDefaultInstance() {
}

NavConfig::NavConfig(const NavConfig& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.NavConfig)
}

void NavConfig::SharedCtor() {
  _cached_size_ = 0;
  stop_delta_distance_ = 0;
  stop_delta_theta_ = 0;
  nav_v_ = 0;
  nav_w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NavConfig::~NavConfig() {
  // @@protoc_insertion_point(destructor:stdmsg.NavConfig)
  SharedDtor();
}

void NavConfig::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NavConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NavConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NavConfig_descriptor_;
}

const NavConfig& NavConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

NavConfig* NavConfig::default_instance_ = NULL;

NavConfig* NavConfig::New(::google::protobuf::Arena* arena) const {
  NavConfig* n = new NavConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NavConfig::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<NavConfig*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(stop_delta_distance_, nav_w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NavConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.NavConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double stop_delta_distance = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_delta_distance_)));
          set_has_stop_delta_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_stop_delta_theta;
        break;
      }

      // optional double stop_delta_theta = 2;
      case 2: {
        if (tag == 17) {
         parse_stop_delta_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_delta_theta_)));
          set_has_stop_delta_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_nav_v;
        break;
      }

      // optional double nav_v = 3;
      case 3: {
        if (tag == 25) {
         parse_nav_v:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &nav_v_)));
          set_has_nav_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_nav_w;
        break;
      }

      // optional double nav_w = 4;
      case 4: {
        if (tag == 33) {
         parse_nav_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &nav_w_)));
          set_has_nav_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.NavConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.NavConfig)
  return false;
#undef DO_
}

void NavConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.NavConfig)
  // optional double stop_delta_distance = 1;
  if (has_stop_delta_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->stop_delta_distance(), output);
  }

  // optional double stop_delta_theta = 2;
  if (has_stop_delta_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->stop_delta_theta(), output);
  }

  // optional double nav_v = 3;
  if (has_nav_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->nav_v(), output);
  }

  // optional double nav_w = 4;
  if (has_nav_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->nav_w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.NavConfig)
}

::google::protobuf::uint8* NavConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.NavConfig)
  // optional double stop_delta_distance = 1;
  if (has_stop_delta_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->stop_delta_distance(), target);
  }

  // optional double stop_delta_theta = 2;
  if (has_stop_delta_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->stop_delta_theta(), target);
  }

  // optional double nav_v = 3;
  if (has_nav_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->nav_v(), target);
  }

  // optional double nav_w = 4;
  if (has_nav_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->nav_w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.NavConfig)
  return target;
}

int NavConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional double stop_delta_distance = 1;
    if (has_stop_delta_distance()) {
      total_size += 1 + 8;
    }

    // optional double stop_delta_theta = 2;
    if (has_stop_delta_theta()) {
      total_size += 1 + 8;
    }

    // optional double nav_v = 3;
    if (has_nav_v()) {
      total_size += 1 + 8;
    }

    // optional double nav_w = 4;
    if (has_nav_w()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NavConfig::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NavConfig* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NavConfig>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NavConfig::MergeFrom(const NavConfig& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stop_delta_distance()) {
      set_stop_delta_distance(from.stop_delta_distance());
    }
    if (from.has_stop_delta_theta()) {
      set_stop_delta_theta(from.stop_delta_theta());
    }
    if (from.has_nav_v()) {
      set_nav_v(from.nav_v());
    }
    if (from.has_nav_w()) {
      set_nav_w(from.nav_w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NavConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NavConfig::CopyFrom(const NavConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavConfig::IsInitialized() const {

  return true;
}

void NavConfig::Swap(NavConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NavConfig::InternalSwap(NavConfig* other) {
  std::swap(stop_delta_distance_, other->stop_delta_distance_);
  std::swap(stop_delta_theta_, other->stop_delta_theta_);
  std::swap(nav_v_, other->nav_v_);
  std::swap(nav_w_, other->nav_w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NavConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NavConfig_descriptor_;
  metadata.reflection = NavConfig_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NavConfig

// optional double stop_delta_distance = 1;
bool NavConfig::has_stop_delta_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NavConfig::set_has_stop_delta_distance() {
  _has_bits_[0] |= 0x00000001u;
}
void NavConfig::clear_has_stop_delta_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
void NavConfig::clear_stop_delta_distance() {
  stop_delta_distance_ = 0;
  clear_has_stop_delta_distance();
}
 double NavConfig::stop_delta_distance() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.stop_delta_distance)
  return stop_delta_distance_;
}
 void NavConfig::set_stop_delta_distance(double value) {
  set_has_stop_delta_distance();
  stop_delta_distance_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.stop_delta_distance)
}

// optional double stop_delta_theta = 2;
bool NavConfig::has_stop_delta_theta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NavConfig::set_has_stop_delta_theta() {
  _has_bits_[0] |= 0x00000002u;
}
void NavConfig::clear_has_stop_delta_theta() {
  _has_bits_[0] &= ~0x00000002u;
}
void NavConfig::clear_stop_delta_theta() {
  stop_delta_theta_ = 0;
  clear_has_stop_delta_theta();
}
 double NavConfig::stop_delta_theta() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.stop_delta_theta)
  return stop_delta_theta_;
}
 void NavConfig::set_stop_delta_theta(double value) {
  set_has_stop_delta_theta();
  stop_delta_theta_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.stop_delta_theta)
}

// optional double nav_v = 3;
bool NavConfig::has_nav_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void NavConfig::set_has_nav_v() {
  _has_bits_[0] |= 0x00000004u;
}
void NavConfig::clear_has_nav_v() {
  _has_bits_[0] &= ~0x00000004u;
}
void NavConfig::clear_nav_v() {
  nav_v_ = 0;
  clear_has_nav_v();
}
 double NavConfig::nav_v() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.nav_v)
  return nav_v_;
}
 void NavConfig::set_nav_v(double value) {
  set_has_nav_v();
  nav_v_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.nav_v)
}

// optional double nav_w = 4;
bool NavConfig::has_nav_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void NavConfig::set_has_nav_w() {
  _has_bits_[0] |= 0x00000008u;
}
void NavConfig::clear_has_nav_w() {
  _has_bits_[0] &= ~0x00000008u;
}
void NavConfig::clear_nav_w() {
  nav_w_ = 0;
  clear_has_nav_w();
}
 double NavConfig::nav_w() const {
  // @@protoc_insertion_point(field_get:stdmsg.NavConfig.nav_w)
  return nav_w_;
}
 void NavConfig::set_nav_w(double value) {
  set_has_nav_w();
  nav_w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.NavConfig.nav_w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Light::kLightflagFieldNumber;
const int Light::kNumberFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Light::Light()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Light)
}

void Light::InitAsDefaultInstance() {
}

Light::Light(const Light& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Light)
}

void Light::SharedCtor() {
  _cached_size_ = 0;
  lightflag_ = 0;
  number_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Light::~Light() {
  // @@protoc_insertion_point(destructor:stdmsg.Light)
  SharedDtor();
}

void Light::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Light::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Light::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Light_descriptor_;
}

const Light& Light::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Light* Light::default_instance_ = NULL;

Light* Light::New(::google::protobuf::Arena* arena) const {
  Light* n = new Light;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Light::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Light*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(lightflag_, number_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Light::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Light)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 lightflag = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lightflag_)));
          set_has_lightflag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_number;
        break;
      }

      // optional int32 number = 2;
      case 2: {
        if (tag == 16) {
         parse_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Light)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Light)
  return false;
#undef DO_
}

void Light::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Light)
  // optional int32 lightflag = 1;
  if (has_lightflag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->lightflag(), output);
  }

  // optional int32 number = 2;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->number(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Light)
}

::google::protobuf::uint8* Light::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Light)
  // optional int32 lightflag = 1;
  if (has_lightflag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->lightflag(), target);
  }

  // optional int32 number = 2;
  if (has_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->number(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Light)
  return target;
}

int Light::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional int32 lightflag = 1;
    if (has_lightflag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lightflag());
    }

    // optional int32 number = 2;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->number());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Light::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Light* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Light>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Light::MergeFrom(const Light& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lightflag()) {
      set_lightflag(from.lightflag());
    }
    if (from.has_number()) {
      set_number(from.number());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Light::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Light::CopyFrom(const Light& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Light::IsInitialized() const {

  return true;
}

void Light::Swap(Light* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Light::InternalSwap(Light* other) {
  std::swap(lightflag_, other->lightflag_);
  std::swap(number_, other->number_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Light::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Light_descriptor_;
  metadata.reflection = Light_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Light

// optional int32 lightflag = 1;
bool Light::has_lightflag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Light::set_has_lightflag() {
  _has_bits_[0] |= 0x00000001u;
}
void Light::clear_has_lightflag() {
  _has_bits_[0] &= ~0x00000001u;
}
void Light::clear_lightflag() {
  lightflag_ = 0;
  clear_has_lightflag();
}
 ::google::protobuf::int32 Light::lightflag() const {
  // @@protoc_insertion_point(field_get:stdmsg.Light.lightflag)
  return lightflag_;
}
 void Light::set_lightflag(::google::protobuf::int32 value) {
  set_has_lightflag();
  lightflag_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Light.lightflag)
}

// optional int32 number = 2;
bool Light::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Light::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
void Light::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void Light::clear_number() {
  number_ = 0;
  clear_has_number();
}
 ::google::protobuf::int32 Light::number() const {
  // @@protoc_insertion_point(field_get:stdmsg.Light.number)
  return number_;
}
 void Light::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Light.number)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace stdmsg

// @@protoc_insertion_point(global_scope)
